var e={};!function(e){function n(e,n,r){return r.a=e,r.f=n,r}function r(e){return n(2,e,function(n){return function(r){return e(n,r)}})}function o(e){return n(3,e,function(n){return function(r){return function(o){return e(n,r,o)}}})}function t(e){return n(4,e,function(n){return function(r){return function(o){return function(t){return e(n,r,o,t)}}}})}function a(e){return n(5,e,function(n){return function(r){return function(o){return function(t){return function(a){return e(n,r,o,t,a)}}}}})}function i(e){return n(6,e,function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return e(n,r,o,t,a,i)}}}}}})}function c(e){return n(8,e,function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return function(c){return function(l){return e(n,r,o,t,a,i,c,l)}}}}}}}})}function l(e,n,r){return 2===e.a?e.f(n,r):e(n)(r)}function u(e,n,r,o){return 3===e.a?e.f(n,r,o):e(n)(r)(o)}function f(e,n,r,o,t){return 4===e.a?e.f(n,r,o,t):e(n)(r)(o)(t)}function s(e,n,r,o,t,a){return 5===e.a?e.f(n,r,o,t,a):e(n)(r)(o)(t)(a)}function d(e,n,r,o,t,a,i){return 6===e.a?e.f(n,r,o,t,a,i):e(n)(r)(o)(t)(a)(i)}function m(e,n,r,o,t,a,i,c,l){return 8===e.a?e.f(n,r,o,t,a,i,c,l):e(n)(r)(o)(t)(a)(i)(c)(l)}var v=o(function(e,n,r){for(var o=Array(e),t=0;e>t;t++)o[t]=r(n+t);return o}),p=r(function(e,n){for(var r=Array(e),o=0;e>o&&n.b;o++)r[o]=n.a,n=n.b;return r.length=o,M(r,n)}),g=r(function(e,n){return n[e]});function b(e){throw Error("https://github.com/elm/core/blob/1.0.0/hints/"+e+".md")}function h(e,n){for(var r,o=[],t=C(e,n,0,o);t&&(r=o.pop());t=C(r.a,r.b,0,o));return t}function C(e,n,r,o){if(e===n)return!0;if("object"!=typeof e||null===e||null===n)return"function"==typeof e&&b(5),!1;if(r>100)return o.push(M(e,n)),!0;for(var t in 0>e.$&&(e=nT(e),n=nT(n)),e)if(!C(e[t],n[t],r+1,o))return!1;return!0}function x(e,n,r){if("object"!=typeof e)return e===n?0:n>e?-1:1;if(void 0===e.$)return(r=x(e.a,n.a))||(r=x(e.b,n.b))?r:x(e.c,n.c);for(;e.b&&n.b&&!(r=x(e.a,n.a));e=e.b,n=n.b);return r||(e.b?1:n.b?-1:0)}var T=r(function(e,n){var r=x(e,n);return 0>r?ny:r?nP:nM});function M(e,n){return{a:e,b:n}}function P(e,n,r){return{a:e,b:n,c:r}}function y(e,n){if("string"==typeof e)return e+n;if(!e.b)return n;var r=w(e.a,n);e=e.b;for(var o=r;e.b;e=e.b)o=o.b=w(e.a,n);return r}var L={$:0};function w(e,n){return{$:1,a:e,b:n}}var D=r(w);function N(e){for(var n=L,r=e.length;r--;)n=w(e[r],n);return n}var S=o(function(e,n,r){for(var o=[];n.b&&r.b;n=n.b,r=r.b)o.push(l(e,n.a,r.a));return N(o)}),_=r(function(e,n){return e+n}),z=r(Math.pow),$=Math.PI,A=Math.cos,R=Math.sin,F=Math.tan,B=Math.ceil,k=Math.floor,E=Math.round,V=Math.sqrt,j=Math.log,H=r(function(e,n){return n.join(e)});function I(e){return{$:2,b:e}}var W=I(function(e){return"number"!=typeof e?Q("an INT",e):e>-0x7fffffff&&0x7fffffff>e&&(0|e)===e?nz(e):!isFinite(e)||e%1?Q("an INT",e):nz(e)});I(function(e){return"boolean"==typeof e?nz(e):Q("a BOOL",e)}),I(function(e){return"number"==typeof e?nz(e):Q("a FLOAT",e)}),I(function(e){return nz(e)}),I(function(e){return"string"==typeof e?nz(e):e instanceof String?nz(e+""):Q("a STRING",e)});var O=r(function(e,n){return{$:6,d:e,b:n}});function U(e,n){return{$:9,f:e,g:n}}var Y=r(function(e,n){return U(e,[n])}),q=o(function(e,n,r){return U(e,[n,r])}),G=r(function(e,n){return Z(e,n)});function Z(e,n){switch(e.$){case 2:return e.b(n);case 5:return null===n?nz(e.c):Q("null",n);case 3:return K(n)?X(e.b,n,N):Q("a LIST",n);case 4:return K(n)?X(e.b,n,J):Q("an ARRAY",n);case 6:var r=e.d;if("object"!=typeof n||null===n||!(r in n))return Q("an OBJECT with a field named `"+r+"`",n);var o=Z(e.b,n[r]);return n3(o)?o:nD(l(nS,r,o.a));case 7:var t=e.e;return K(n)?n.length>t?n3(o=Z(e.b,n[t]))?o:nD(l(n_,t,o.a)):Q("a LONGER array. Need index "+t+" but only see "+n.length+" entries",n):Q("an ARRAY",n);case 8:if("object"!=typeof n||null===n||K(n))return Q("an OBJECT",n);var a=L;for(var i in n)if(n.hasOwnProperty(i)){if(!n3(o=Z(e.b,n[i])))return nD(l(nS,i,o.a));a=w(M(i,o.a),a)}return nz(nH(a));case 9:for(var c=e.f,u=e.g,f=0;u.length>f;f++){if(!n3(o=Z(u[f],n)))return o;c=c(o.a)}return nz(c);case 10:return n3(o=Z(e.b,n))?Z(e.h(o.a),n):o;case 11:for(var s=L,d=e.g;d.b;d=d.b){if(n3(o=Z(d.a,n)))return o;s=w(o.a,s)}return nD(n$(nH(s)));case 1:return nD(l(nN,e.a,n));case 0:return nz(e.a)}}function X(e,n,r){for(var o=n.length,t=Array(o),a=0;o>a;a++){var i=Z(e,n[a]);if(!n3(i))return nD(l(n_,a,i.a));t[a]=i.a}return nz(r(t))}function K(e){return Array.isArray(e)||"undefined"!=typeof FileList&&e instanceof FileList}function J(e){return l(n0,e.length,function(n){return e[n]})}function Q(e,n){return nD(l(nN,"Expecting "+e,n))}function ee(e,n){if(e===n)return!0;if(e.$!==n.$)return!1;switch(e.$){case 0:case 1:return e.a===n.a;case 2:return e.b===n.b;case 5:return e.c===n.c;case 3:case 4:case 8:return ee(e.b,n.b);case 6:return e.d===n.d&&ee(e.b,n.b);case 7:return e.e===n.e&&ee(e.b,n.b);case 9:return e.f===n.f&&en(e.g,n.g);case 10:return e.h===n.h&&ee(e.b,n.b);case 11:return en(e.g,n.g)}}function en(e,n){var r=e.length;if(r!==n.length)return!1;for(var o=0;r>o;o++)if(!ee(e[o],n[o]))return!1;return!0}function er(e){return{$:0,a:e}}function eo(e){return{$:2,b:e,c:null}}var et=r(function(e,n){return{$:3,b:e,d:n}}),ea=0;function ei(e){var n={$:0,e:ea++,f:e,g:null,h:[]};return ed(n),n}function ec(e){return eo(function(n){n(er(ei(e)))})}function el(e,n){e.h.push(n),ed(e)}var eu=r(function(e,n){return eo(function(r){el(e,n),r(er(0))})}),ef=!1,es=[];function ed(e){if(es.push(e),!ef){for(ef=!0;e=es.shift();)(function(e){for(;e.f;){var n=e.f.$;if(0===n||1===n){for(;e.g&&e.g.$!==n;)e.g=e.g.i;if(!e.g)return;e.f=e.g.b(e.f.a),e.g=e.g.i}else{if(2===n)return void(e.f.c=e.f.b(function(n){e.f=n,ed(e)}));if(5===n){if(0===e.h.length)return;e.f=e.f.b(e.h.shift())}else e.g={$:3===n?0:1,b:e.f.b,i:e.g},e.f=e.f.d}}})(e);ef=!1}}var em={};function ev(e,n,r,o,t){return{b:e,c:n,d:r,e:o,f:t}}var ep=r(function(e,n){return eo(function(r){e.g(n),r(er(0))})}),eg=r(function(e,n){return l(eu,e.h,{$:0,a:n})});function eb(e){return function(n){return{$:1,k:e,l:n}}}var eh,eC=[],ex=!1;function eT(e,n,r){if(eC.push({p:e,q:n,r:r}),!ex){ex=!0;for(var o;o=eC.shift();)(function(e,n,r){var o={};for(var t in eM(!0,n,o,null),eM(!1,r,o,null),e)el(e[t],{$:"fx",a:o[t]||{i:L,j:L}})})(o.p,o.q,o.r);ex=!1}}function eM(e,n,r,o){switch(n.$){case 1:var t,a,i=n.k,c=(t=n.l,l(e?em[i].e:em[i].f,function(e){for(var n=o;n;n=n.t)e=n.s(e);return e},t));return void(r[i]=(a=(a=r[i])||{i:L,j:L},e?a.i=w(c,a.i):a.j=w(c,a.j),a));case 2:for(var u=n.m;u.b;u=u.b)eM(e,u.a,r,o);return;case 3:return void eM(e,n.o,r,{s:n.n,t:o})}}var eP="undefined"!=typeof document?document:{};function ey(e,n){e.appendChild(n)}var eL,ew=r(function(e,n){return r(function(r,o){for(var t=[],a=0;o.b;o=o.b){var i=o.a;a+=i.b||0,t.push(i)}return a+=t.length,{$:1,c:n,d:e_(r),e:t,f:e,b:a}})})(void 0),eD=r(function(e,n){return r(function(r,o){for(var t=[],a=0;o.b;o=o.b){var i=o.a;a+=i.b.b||0,t.push(i)}return a+=t.length,{$:2,c:n,d:e_(r),e:t,f:e,b:a}})})(void 0),eN=r(function(e,n){return{$:"a1",n:e,o:n}}),eS=r(function(e,n){return{$:"a3",n:e,o:n}});function e_(e){for(var n={};e.b;e=e.b){var r=e.a,o=r.$,t=r.n,a=r.o;if("a2"!==o){var i=n[o]||(n[o]={});"a3"===o&&"class"===t?ez(i,t,a):i[t]=a}else"className"===t?ez(n,t,a):n[t]=a}return n}function ez(e,n,r){var o=e[n];e[n]=o?o+" "+r:r}function e$(e,n){var r=e.$;if(5===r)return e$(e.k||(e.k=e.m()),n);if(0===r)return eP.createTextNode(e.a);if(4===r){for(var o=e.k,t=e.j;4===o.$;)"object"!=typeof t?t=[t,o.j]:t.push(o.j),o=o.k;var a={j:t,p:n};return(i=e$(o,a)).elm_event_node_ref=a,i}if(3===r)return eA(i=e.h(e.g),n,e.d),i;var i=e.f?eP.createElementNS(e.f,e.c):eP.createElement(e.c);eh&&"a"==e.c&&i.addEventListener("click",eh(i)),eA(i,n,e.d);for(var c=e.e,l=0;c.length>l;l++)ey(i,e$(1===r?c[l]:c[l].b,n));return i}function eA(e,n,r){for(var o in r){var t=r[o];"a1"===o?function(e,n){var r=e.style;for(var o in n)r[o]=n[o]}(e,t):"a0"===o?function(e,n,r){var o=e.elmFs||(e.elmFs={});for(var t in r){var a=r[t],i=o[t];if(a){if(i){if(i.q.$===a.$){i.q=a;continue}e.removeEventListener(t,i)}i=function(e,n){function r(n){var o=r.q,t=Z(o.a,n);if(n3(t)){for(var a,i=n1(o),c=t.a,l=i?3>i?c.a:c.as:c,u=1==i?c.b:3==i&&c.cP,f=(u&&n.stopPropagation(),(2==i?c.b:3==i&&c.cG)&&n.preventDefault(),e);a=f.j;){if("function"==typeof a)l=a(l);else for(var s=a.length;s--;)l=a[s](l);f=f.p}f(l,u)}}return r.q=n,r}(n,a),e.addEventListener(t,i,eL&&{passive:2>n1(a)}),o[t]=i}else e.removeEventListener(t,i),o[t]=void 0}}(e,n,t):"a3"===o?function(e,n){for(var r in n){var o=n[r];void 0!==o?e.setAttribute(r,o):e.removeAttribute(r)}}(e,t):"a4"===o?function(e,n){for(var r in n){var o=n[r],t=o.f,a=o.o;void 0!==a?e.setAttributeNS(t,r,a):e.removeAttributeNS(t,r)}}(e,t):("value"!==o&&"checked"!==o||e[o]!==t)&&(e[o]=t)}}try{window.addEventListener("t",null,Object.defineProperty({},"passive",{get:function(){eL=!0}}))}catch(e){}function eR(e,n,r,o){var t={$:n,r:r,s:o,t:void 0,u:void 0};return e.push(t),t}function eF(e,n,r,o){if(e!==n){var t=e.$,a=n.$;if(t!==a){if(1!==t||2!==a)return void eR(r,0,o,n);n=function(e){for(var n=e.e,r=n.length,o=Array(r),t=0;r>t;t++)o[t]=n[t].b;return{$:1,c:e.c,d:e.d,e:o,f:e.f,b:e.b}}(n),a=1}switch(a){case 5:for(var i=e.l,c=n.l,l=i.length,u=l===c.length;u&&l--;)u=i[l]===c[l];if(u)return void(n.k=e.k);n.k=n.m();var f=[];return eF(e.k,n.k,f,0),void(f.length>0&&eR(r,1,o,f));case 4:for(var s=e.j,d=n.j,m=!1,v=e.k;4===v.$;)m=!0,"object"!=typeof s?s=[s,v.j]:s.push(v.j),v=v.k;for(var p=n.k;4===p.$;)m=!0,"object"!=typeof d?d=[d,p.j]:d.push(p.j),p=p.k;return m&&s.length!==d.length?void eR(r,0,o,n):((m?function(e,n){for(var r=0;e.length>r;r++)if(e[r]!==n[r])return!1;return!0}(s,d):s===d)||eR(r,2,o,d),void eF(v,p,r,o+1));case 0:return void(e.a!==n.a&&eR(r,3,o,n.a));case 1:return void eB(e,n,r,o,eE);case 2:return void eB(e,n,r,o,eV);case 3:if(e.h!==n.h)return void eR(r,0,o,n);var g=ek(e.d,n.d);g&&eR(r,4,o,g);var b=n.i(e.g,n.g);return void(b&&eR(r,5,o,b))}}}function eB(e,n,r,o,t){if(e.c===n.c&&e.f===n.f){var a=ek(e.d,n.d);a&&eR(r,4,o,a),t(e,n,r,o)}else eR(r,0,o,n)}function ek(e,n,r){var o;for(var t in e)if("a1"!==t&&"a0"!==t&&"a3"!==t&&"a4"!==t){if(t in n){var a=e[t],i=n[t];a===i&&"value"!==t&&"checked"!==t||"a0"===r&&a.$==i.$&&ee(a.a,i.a)||((o=o||{})[t]=i)}else(o=o||{})[t]=r?"a1"===r?"":"a0"===r||"a3"===r?void 0:{f:e[t].f,o:void 0}:"string"==typeof e[t]?"":null}else{var c=ek(e[t],n[t]||{},t);c&&((o=o||{})[t]=c)}for(var l in n)l in e||((o=o||{})[l]=n[l]);return o}function eE(e,n,r,o){var t=e.e,a=n.e,i=t.length,c=a.length;i>c?eR(r,6,o,{v:c,i:i-c}):c>i&&eR(r,7,o,{v:i,e:a});for(var l=c>i?i:c,u=0;l>u;u++){var f=t[u];eF(f,a[u],r,++o),o+=f.b||0}}function eV(e,n,r,o){for(var t=[],a={},i=[],c=e.e,l=n.e,u=c.length,f=l.length,s=0,d=0,m=o;u>s&&f>d;){var v=(w=c[s]).a,p=(D=l[d]).a,g=w.b,b=D.b,h=void 0,C=void 0;if(v!==p){var x=c[s+1],T=l[d+1];if(x){var M=x.a,P=x.b;C=p===M}if(T){var y=T.a,L=T.b;h=v===y}if(h&&C)eF(g,L,t,++m),eH(a,t,v,b,d,i),m+=g.b||0,eI(a,t,v,P,++m),m+=P.b||0,s+=2,d+=2;else if(h)m++,eH(a,t,p,b,d,i),eF(g,L,t,m),m+=g.b||0,s+=1,d+=2;else if(C)eI(a,t,v,g,++m),m+=g.b||0,eF(P,b,t,++m),m+=P.b||0,s+=2,d+=1;else{if(!x||M!==y)break;eI(a,t,v,g,++m),eH(a,t,p,b,d,i),m+=g.b||0,eF(P,L,t,++m),m+=P.b||0,s+=2,d+=2}}else eF(g,b,t,++m),m+=g.b||0,s++,d++}for(;u>s;)m++,eI(a,t,(w=c[s]).a,g=w.b,m),m+=g.b||0,s++;for(;f>d;){var w,D,N=N||[];eH(a,t,(D=l[d]).a,D.b,void 0,N),d++}(t.length>0||i.length>0||N)&&eR(r,8,o,{w:t,x:i,y:N})}var ej="_elmW6BL";function eH(e,n,r,o,t,a){var i=e[r];if(!i)return a.push({r:t,A:i={c:0,z:o,r:t,s:void 0}}),void(e[r]=i);if(1===i.c){a.push({r:t,A:i}),i.c=2;var c=[];return eF(i.z,o,c,i.r),i.r=t,void(i.s.s={w:c,A:i})}eH(e,n,r+ej,o,t,a)}function eI(e,n,r,o,t){var a=e[r];if(a){if(0===a.c){a.c=2;var i=[];return eF(o,a.z,i,t),void eR(n,9,t,{w:i,A:a})}eI(e,n,r+ej,o,t)}else{var c=eR(n,9,t,void 0);e[r]={c:1,z:o,r:t,s:c}}}var eW=t(function(e,n,r,o){return function(e,n,r,o,t,a){var i=l(G,e,n?n.flags:void 0);n3(i)||b(2);var c={},s=r(i.a),d=s.a,m=a(p,d),v=function(e,n){var r;for(var o in em){var t=em[o];t.a&&((r=r||{})[o]=t.a(o,n)),e[o]=function(e,n){var r={g:n,h:void 0},o=e.c,t=e.d,a=e.e,i=e.f;return r.h=ei(l(et,function e(n){return l(et,e,{$:5,b:function(e){var c=e.a;return 0===e.$?u(t,r,c,n):a&&i?f(o,r,c.i,c.j,n):u(o,r,a?c.i:c.j,n)}})},e.b))}(t,n)}return r}(c,p);function p(e,n){var r=l(o,e,d);m(d=r.a,n),eT(c,r.b,t(d))}return eT(c,s.b,t(d)),v?{ports:v}:{}}(n,o,e.eI,e.e3,e.e0,function(n,r){var t=e.e6,a=o.node,i=function e(n){if(3===n.nodeType)return{$:0,a:n.textContent};if(1!==n.nodeType)return{$:0,a:""};for(var r=L,o=n.attributes,t=o.length;t--;){var a=o[t];r=w(l(eS,a.name,a.value),r)}var i=n.tagName.toLowerCase(),c=L,f=n.childNodes;for(t=f.length;t--;)c=w(e(f[t]),c);return u(ew,i,r,c)}(a);return function(e,n){n(e);var r=0;function o(){r=1===r?0:(eU(o),n(e),1)}return function(t,a){e=t,a?(n(e),2===r&&(r=1)):(0===r&&eU(o),r=2)}}(r,function(e){var r,o,c,l=t(e),u=(eF(i,l,r=[],0),r);o=a,c=i,a=0===u.length?o:(function e(n,r,o,t){(function n(r,o,t,a,i,c,l){for(var u=t[a],f=u.r;f===i;){var s=u.$;if(1===s)e(r,o.k,u.s,l);else if(8===s)u.t=r,u.u=l,(d=u.s.w).length>0&&n(r,o,d,0,i,c,l);else if(9===s){u.t=r,u.u=l;var d,m=u.s;m&&(m.A.s=r,(d=m.w).length>0&&n(r,o,d,0,i,c,l))}else u.t=r,u.u=l;if(!(u=t[++a])||(f=u.r)>c)return a}var v=o.$;if(4===v){for(var p=o.k;4===p.$;)p=p.k;return n(r,p,t,a,i+1,c,r.elm_event_node_ref)}for(var g=o.e,b=r.childNodes,h=0;g.length>h;h++){i++;var C=1===v?g[h]:g[h].b,x=i+(C.b||0);if(!(i>f||f>x||(u=t[a=n(b[h],C,t,a,i,x,l)])&&(f=u.r)<=c))break;i=x}return a})(n,r,o,0,0,r.b,t)}(o,c,u,n),function e(n,r){for(var o=0;r.length>o;o++){var t=r[o],a=t.t,i=function(n,r){switch(r.$){case 0:var o,t,a,i;return o=r.s,t=r.u,a=n.parentNode,(i=e$(o,t)).elm_event_node_ref||(i.elm_event_node_ref=n.elm_event_node_ref),a&&i!==n&&a.replaceChild(i,n),i;case 4:return eA(n,r.u,r.s),n;case 3:return n.replaceData(0,n.length,r.s),n;case 1:return e(n,r.s);case 2:return n.elm_event_node_ref?n.elm_event_node_ref.j=r.s:n.elm_event_node_ref={j:r.s,p:r.u},n;case 6:for(var c=r.s,l=0;c.i>l;l++)n.removeChild(n.childNodes[c.v]);return n;case 7:for(var u=(c=r.s).e,f=n.childNodes[l=c.v];u.length>l;l++)n.insertBefore(e$(u[l],r.u),f);return n;case 9:if(!(c=r.s))return n.parentNode.removeChild(n),n;var s=c.A;return void 0!==s.r&&n.parentNode.removeChild(n),s.s=e(n,c.w),n;case 8:return function(n,r){var o=r.s,t=function(e,n){if(e){for(var r=eP.createDocumentFragment(),o=0;e.length>o;o++){var t=e[o].A;ey(r,2===t.c?t.s:e$(t.z,n.u))}return r}}(o.y,r);n=e(n,o.w);for(var a=o.x,i=0;a.length>i;i++){var c=a[i],l=c.A,u=2===l.c?l.s:e$(l.z,r.u);n.insertBefore(u,n.childNodes[c.r])}return t&&ey(n,t),n}(n,r);case 5:return r.s(n);default:b(10)}}(a,t);a===n&&(n=i)}return n}(o,u)),i=l})})}),eO="undefined"!=typeof cancelAnimationFrame?cancelAnimationFrame:function(e){clearTimeout(e)},eU="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:function(e){return setTimeout(e,1e3/60)},eY={addEventListener:function(){},removeEventListener:function(){}},eq="undefined"!=typeof document?document:eY,eG="undefined"!=typeof window?window:eY,eZ=o(function(e,n,r){return ec(eo(function(){function o(e){ei(r(e))}return e.addEventListener(n,o,eL&&{passive:!0}),function(){e.removeEventListener(n,o)}}))}),eX=r(function(e,n){var r=Z(e,n);return n3(r)?nA(r.a):nR}),eK=r(function(e,n){return new Float64Array([e,n])});new Float64Array(3),new Float64Array(3),new Float64Array(3);var eJ=o(function(e,n,r){return new Float64Array([e,n,r])}),eQ=r(function(e,n){return new Float64Array([n[0]*e,n[1]*e,n[2]*e])}),e0=t(function(e,n,r,o){return new Float64Array([e,n,r,o])});new Float64Array(16),new Float64Array(16),new Float64Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);var e3=0;function e1(e,n){for(;n.b;n=n.b)e(n.a)}function e2(e){for(var n=0;e.b;e=e.b)n++;return n}var e4="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:function(e){setTimeout(e,1e3/60)},e5=a(function(e,n,r,o,t){return{$:0,a:e,b:n,c:r,d:o,e:t}}),e6=r(function(e,n){var r=e.blend;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.BLEND),r.enabled=!0),r.a===n.a&&r.d===n.d||(e.gl.blendEquationSeparate(n.a,n.d),r.a=n.a,r.d=n.d),r.b===n.b&&r.c===n.c&&r.e===n.e&&r.f===n.f||(e.gl.blendFuncSeparate(n.b,n.c,n.e,n.f),r.b=n.b,r.c=n.c,r.e=n.e,r.f=n.f),r.g===n.g&&r.h===n.h&&r.i===n.i&&r.j===n.j||(e.gl.blendColor(n.g,n.h,n.i,n.j),r.g=n.g,r.h=n.h,r.i=n.i,r.j=n.j)}),e7=r(function(e,n){var r=e.depthTest;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.DEPTH_TEST),r.enabled=!0),r.a!==n.a&&(e.gl.depthFunc(n.a),r.a=n.a),r.b!==n.b&&(e.gl.depthMask(n.b),r.b=n.b),r.c===n.c&&r.d===n.d||(e.gl.depthRange(n.c,n.d),r.c=n.c,r.d=n.d)}),e8=r(function(e,n){var r=e.stencilTest;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.STENCIL_TEST),r.enabled=!0),r.d===n.d&&r.a===n.a&&r.b===n.b||(e.gl.stencilFuncSeparate(e.gl.FRONT,n.d,n.a,n.b),r.d=n.d),r.e===n.e&&r.f===n.f&&r.g===n.g||(e.gl.stencilOpSeparate(e.gl.FRONT,n.e,n.f,n.g),r.e=n.e,r.f=n.f,r.g=n.g),r.c!==n.c&&(e.gl.stencilMask(n.c),r.c=n.c),r.h===n.h&&r.a===n.a&&r.b===n.b||(e.gl.stencilFuncSeparate(e.gl.BACK,n.h,n.a,n.b),r.h=n.h,r.a=n.a,r.b=n.b),r.i===n.i&&r.j===n.j&&r.k===n.k||(e.gl.stencilOpSeparate(e.gl.BACK,n.i,n.j,n.k),r.i=n.i,r.j=n.j,r.k=n.k)}),e9=r(function(e,n){var r=e.scissor;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SCISSOR_TEST),r.enabled=!0),r.a===n.a&&r.b===n.b&&r.c===n.c&&r.d===n.d||(e.gl.scissor(n.a,n.b,n.c,n.d),r.a=n.a,r.b=n.b,r.c=n.c,r.d=n.d)}),ne=r(function(e,n){var r=e.colorMask;r.toggle=e.toggle,r.enabled=!0,r.a===n.a&&r.b===n.b&&r.c===n.c&&r.d===n.d||(e.gl.colorMask(n.a,n.b,n.c,n.d),r.a=n.a,r.b=n.b,r.c=n.c,r.d=n.d)}),nn=r(function(e,n){var r=e.cullFace;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.CULL_FACE),r.enabled=!0),r.a!==n.a&&(e.gl.cullFace(n.a),r.a=n.a)}),nr=r(function(e,n){var r=e.polygonOffset;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.POLYGON_OFFSET_FILL),r.enabled=!0),r.a===n.a&&r.b===n.b||(e.gl.polygonOffset(n.a,n.b),r.a=n.a,r.b=n.b)}),no=r(function(e,n){var r=e.sampleCoverage;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SAMPLE_COVERAGE),r.enabled=!0),r.a===n.a&&r.b===n.b||(e.gl.sampleCoverage(n.a,n.b),r.a=n.a,r.b=n.b)}),nt=function(e){e.scissor.enabled&&(e.gl.disable(e.gl.SCISSOR_TEST),e.scissor.enabled=!1)},na=function(e){var n=e.colorMask;n.a&&n.b&&n.c&&n.d||(e.gl.colorMask(!0,!0,!0,!0),n.a=!0,n.b=!0,n.c=!0,n.d=!0)},ni=["blend","depthTest","stencilTest","scissor","colorMask","cullFace","polygonOffset","sampleCoverage","sampleAlphaToCoverage"],nc=[function(e){e.blend.enabled&&(e.gl.disable(e.gl.BLEND),e.blend.enabled=!1)},function(e){e.depthTest.enabled&&(e.gl.disable(e.gl.DEPTH_TEST),e.depthTest.enabled=!1)},function(e){e.stencilTest.enabled&&(e.gl.disable(e.gl.STENCIL_TEST),e.stencilTest.enabled=!1)},nt,na,function(e){e.gl.disable(e.gl.CULL_FACE)},function(e){e.gl.disable(e.gl.POLYGON_OFFSET_FILL)},function(e){e.gl.disable(e.gl.SAMPLE_COVERAGE)},function(e){e.gl.disable(e.gl.SAMPLE_ALPHA_TO_COVERAGE)}];function nl(e,n,r){var o=e.createShader(r);return e.shaderSource(o,"#extension GL_OES_standard_derivatives : enable\n"+n),e.compileShader(o),o}function nu(e,n){switch(n){case e.FLOAT:return{size:1,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC2:return{size:2,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC3:return{size:3,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC4:return{size:4,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_MAT4:return{size:4,arraySize:4,type:Float32Array,baseType:e.FLOAT};case e.INT:return{size:1,arraySize:1,type:Int32Array,baseType:e.INT}}}var nf=r(function(e,n){var r=e.f,o=r.gl;return o&&(o.viewport(0,0,o.drawingBufferWidth,o.drawingBufferHeight),r.depthTest.b||(o.depthMask(!0),r.depthTest.b=!0),r.stencilTest.c!==r.STENCIL_WRITEMASK&&(o.stencilMask(r.STENCIL_WRITEMASK),r.stencilTest.c=r.STENCIL_WRITEMASK),nt(r),na(r),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT|o.STENCIL_BUFFER_BIT),e1(function(n){if(n.d.b.b){if(n.b.id&&n.c.id&&(t=n.b.id+"#"+n.c.id,a=r.programs[t]),!a){n.b.id?u=r.shaders[n.b.id]:n.b.id=e3++,u||(u=nl(o,n.b.src,o.VERTEX_SHADER),r.shaders[n.b.id]=u),n.c.id?f=r.shaders[n.c.id]:n.c.id=e3++,f||(f=nl(o,n.c.src,o.FRAGMENT_SHADER),r.shaders[n.c.id]=f);var t,a,i,c,l,u,f,s=function(e,n,r){var o=e.createProgram();if(e.attachShader(o,n),e.attachShader(o,r),e.linkProgram(o),!e.getProgramParameter(o,e.LINK_STATUS))throw"Link failed: "+e.getProgramInfoLog(o)+"\nvs info-log: "+e.getShaderInfoLog(n)+"\nfs info-log: "+e.getShaderInfoLog(r);return o}(o,u,f);(a={glProgram:s,attributes:Object.assign({},n.b.attributes,n.c.attributes),currentUniforms:{},activeAttributes:[],activeAttributeLocations:[]}).uniformSetters=function(e,n,r,o){for(var t=r.glProgram,a=r.currentUniforms,i=0,c=n.f,l={},u=e.getProgramParameter(t,e.ACTIVE_UNIFORMS),f=0;u>f;f++){var s=e.getActiveUniform(t,f);l[o[s.name]||s.name]=function(n,r){var o=r.name,t=e.getUniformLocation(n,o);switch(r.type){case e.INT:return function(n){a[o]!==n&&(e.uniform1i(t,n),a[o]=n)};case e.FLOAT:return function(n){a[o]!==n&&(e.uniform1f(t,n),a[o]=n)};case e.FLOAT_VEC2:return function(n){a[o]!==n&&(e.uniform2f(t,n[0],n[1]),a[o]=n)};case e.FLOAT_VEC3:return function(n){a[o]!==n&&(e.uniform3f(t,n[0],n[1],n[2]),a[o]=n)};case e.FLOAT_VEC4:return function(n){a[o]!==n&&(e.uniform4f(t,n[0],n[1],n[2],n[3]),a[o]=n)};case e.FLOAT_MAT4:return function(n){a[o]!==n&&(e.uniformMatrix4fv(t,!1,new Float32Array(n)),a[o]=n)};case e.SAMPLER_2D:var l=i++;return function(n){e.activeTexture(e.TEXTURE0+l);var r=c.textures.get(n);r||(r=n.el(e),c.textures.set(n,r)),e.bindTexture(e.TEXTURE_2D,r),a[o]!==n&&(e.uniform1i(t,l),a[o]=n)};case e.BOOL:return function(n){a[o]!==n&&(e.uniform1i(t,n),a[o]=n)};default:return function(){}}}(t,s)}return l}(o,e,a,Object.assign({},n.b.uniforms,n.c.uniforms));var d=o.getProgramParameter(s,o.ACTIVE_ATTRIBUTES);for(i=0;d>i;i++){var m=o.getActiveAttrib(s,i),v=o.getAttribLocation(s,m.name);a.activeAttributes.push(m),a.activeAttributeLocations.push(v)}t=n.b.id+"#"+n.c.id,r.programs[t]=a}r.lastProgId!==t&&(o.useProgram(a.glProgram),r.lastProgId=t),c=a.uniformSetters,Object.keys(l=n.e).forEach(function(e){var n=c[e];n&&n(l[e])});var p=r.buffers.get(n.d);for(p||(p=function(e,n){if(n.a.c9>0){var r,o,t,a,i,c=e.createBuffer(),l=(r=n.c,o=n.a.c9,a=new Uint32Array(e2(r)*o),i=0,e1(function(e){if(1===o)a[i++]=e;else for(t=0;o>t;t++)a[i++]=e[String.fromCharCode(97+t)]},r),a);return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,c),e.bufferData(e.ELEMENT_ARRAY_BUFFER,l,e.STATIC_DRAW),{numIndices:l.length,indexBuffer:c,buffers:{}}}return{numIndices:n.a.c1*e2(n.b),indexBuffer:null,buffers:{}}}(o,n.d),r.buffers.set(n.d,p)),i=0;a.activeAttributes.length>i;i++){v=a.activeAttributeLocations[i],void 0===p.buffers[(m=a.activeAttributes[i]).name]&&(p.buffers[m.name]=function(e,n,r,o){for(var t=r.a.c1,a=[],i=0;t>i;i++)a.push(String.fromCharCode(97+i));var c=nu(e,n.type);if(void 0===c)throw Error("No info available for: "+n.type);var l=0,u=c.size*c.arraySize*t,f=new c.type(e2(r.b)*u);e1(function(e){(function(e,n,r,o,i){var c;if(1===t)for(c=0;n>c;c++)e[r++]=1===n?o[i]:o[i][c];else a.forEach(function(t){for(c=0;n>c;c++)e[r++]=1===n?o[t][i]:o[t][i][c]})})(f,c.size*c.arraySize,l,e,o[n.name]||n.name),l+=u},r.b);var s=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,s),e.bufferData(e.ARRAY_BUFFER,f,e.STATIC_DRAW),s}(o,m,n.d,a.attributes)),o.bindBuffer(o.ARRAY_BUFFER,p.buffers[m.name]);var g=nu(o,m.type);if(1===g.arraySize)o.enableVertexAttribArray(v),o.vertexAttribPointer(v,g.size,g.baseType,!1,0,0);else for(var b=4*g.size,h=b*g.arraySize,C=0;g.arraySize>C;C++)o.enableVertexAttribArray(v+C),o.vertexAttribPointer(v+C,g.size,g.baseType,!1,h,b*C)}for(r.toggle=!r.toggle,e1(ti(r),n.a),i=0;9>i;i++){var x=r[ni[i]];x.toggle!==r.toggle&&x.enabled&&(nc[i](r),x.enabled=!1,x.toggle=r.toggle)}p.indexBuffer?(o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,p.indexBuffer),o.drawElements(n.d.a.dH,p.numIndices,o.UNSIGNED_INT,0)):o.drawArrays(n.d.a.dH,0,p.numIndices)}},e.g)),n}),ns=o(function(e,n,r){var o;return o={g:r,f:{},h:e},{$:3,d:e_(n),g:o,h:nh,i:nC}}),nd=r(function(e,n){e.contextAttributes.alpha=!0,e.contextAttributes.premultipliedAlpha=n.a}),nm=r(function(e,n){e.contextAttributes.depth=!0,e.sceneSettings.push(function(e){e.clearDepth(n.a)})}),nv=r(function(e,n){e.contextAttributes.stencil=!0,e.sceneSettings.push(function(e){e.clearStencil(n.a)})}),np=r(function(e){e.contextAttributes.antialias=!0}),ng=r(function(e,n){e.sceneSettings.push(function(e){e.clearColor(n.a,n.b,n.c,n.d)})}),nb=r(function(e){e.contextAttributes.preserveDrawingBuffer=!0});function nh(e){var n={contextAttributes:{alpha:!1,depth:!1,stencil:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1},sceneSettings:[]};e1(function(e){return l(ta,n,e)},e.h);var r=eP.createElement("canvas"),o=r.getContext&&(r.getContext("webgl",n.contextAttributes)||r.getContext("experimental-webgl",n.contextAttributes));return o&&"undefined"!=typeof WeakMap?(n.sceneSettings.forEach(function(e){e(o)}),o.getExtension("OES_standard_derivatives"),o.getExtension("OES_element_index_uint"),e.f.gl=o,e.f.toggle=!1,e.f.blend={enabled:!1,toggle:!1},e.f.depthTest={enabled:!1,toggle:!1},e.f.stencilTest={enabled:!1,toggle:!1},e.f.scissor={enabled:!1,toggle:!1},e.f.colorMask={enabled:!1,toggle:!1},e.f.cullFace={enabled:!1,toggle:!1},e.f.polygonOffset={enabled:!1,toggle:!1},e.f.sampleCoverage={enabled:!1,toggle:!1},e.f.sampleAlphaToCoverage={enabled:!1,toggle:!1},e.f.shaders=[],e.f.programs={},e.f.lastProgId=null,e.f.buffers=new WeakMap,e.f.textures=new WeakMap,e.f.STENCIL_WRITEMASK=o.getParameter(o.STENCIL_WRITEMASK),e4(function(){return l(nf,e,r)})):(r=eP.createElement("div")).innerHTML='<a href="https://get.webgl.org/">Enable WebGL</a> to see this content!',r}function nC(e,n){return n.f=e.f,nf(n)}var nx=o(function(e,n,r){for(;;){if(-2===r.$)return n;var o=r.d,t=e,a=u(e,r.b,r.c,u(nx,e,n,r.e));e=t,n=a,r=o}}),nT=function(e){return u(nx,o(function(e,n,r){return l(D,M(e,n),r)}),L,e)},nM=1,nP=2,ny=0,nL=r(function(e,n){return{$:0,a:e,b:n}}),nw=function(e){return{$:1,a:e}},nD=function(e){return{$:1,a:e}},nN=r(function(e,n){return{$:3,a:e,b:n}}),nS=r(function(e,n){return{$:0,a:e,b:n}}),n_=r(function(e,n){return{$:1,a:e,b:n}}),nz=function(e){return{$:0,a:e}},n$=function(e){return{$:2,a:e}},nA=function(e){return{$:0,a:e}},nR={$:1},nF=r(function(e,n){return l(H,e,function(e){for(var n=[];e.b;e=e.b)n.push(e.a);return n}(n))}),nB=o(function(e,n,r){for(;;){if(!r.b)return n;var o=r.b,t=e,a=l(e,r.a,n);e=t,n=a,r=o}}),nk=function(e){return u(nB,r(function(e,n){return n+1}),0,e)},nE=o(function(e,n,r){for(;;){if(x(e,n)>=1)return r;var o=e,t=n-1,a=l(D,n,r);e=o,n=t,r=a}}),nV=r(function(e,n){return u(nE,e,n,L)}),nj=r(function(e,n){return u(S,e,l(nV,0,nk(n)-1),n)}),nH=function(e){return u(nB,D,L,e)},nI=t(function(e,n,r,o){return{$:0,a:e,b:n,c:r,d:o}}),nW=[],nO=r(function(e,n){return j(n)/j(e)}),nU=B(l(nO,2,32)),nY=f(nI,0,nU,nW,nW),nq=function(e){return{$:1,a:e}},nG=function(e){return e.length},nZ=r(function(e,n){return x(e,n)>0?e:n}),nX=r(function(e,n){for(;;){var r=l(p,32,e),o=r.b,t=l(D,{$:0,a:r.a},n);if(!o.b)return nH(t);e=o,n=t}}),nK=r(function(e,n){for(;;){var r=B(n/32);if(1===r)return l(p,32,e).a;e=l(nX,e,L),n=r}}),nJ=r(function(e,n){if(n.m){var r=32*n.m,o=k(l(nO,32,r-1)),t=l(nK,e?nH(n.A):n.A,n.m);return f(nI,nG(n.q)+r,l(nZ,5,o*nU),t,n.q)}return f(nI,nG(n.q),nU,nW,n.q)}),nQ=a(function(e,n,r,o,t){for(;;){if(0>n)return l(nJ,!1,{A:o,m:r/32|0,q:t});var a=nq(u(v,32,n,e));n-=32,o=l(D,a,o)}}),n0=r(function(e,n){if(e>0){var r=e%32;return s(nQ,n,e-r-32,e,L,u(v,r,e-r,n))}return nY}),n3=function(e){return!e.$},n1=function(e){switch(e.$){case 0:return 0;case 1:return 1;case 2:return 2;default:return 3}},n2=function(e){return e},n4=er(0),n5=t(function(e,n,r,o){if(o.b){var t=o.a,a=o.b;if(a.b){var i=a.a,c=a.b;if(c.b){var s=c.a,d=c.b;if(d.b){var m=d.b;return l(e,t,l(e,i,l(e,s,l(e,d.a,r>500?u(nB,e,n,nH(m)):f(n5,e,n,r+1,m)))))}return l(e,t,l(e,i,l(e,s,n)))}return l(e,t,l(e,i,n))}return l(e,t,n)}return n}),n6=o(function(e,n,r){return f(n5,e,n,0,r)}),n7=r(function(e,n){return u(n6,r(function(n,r){return l(D,e(n),r)}),L,n)}),n8=r(function(e,n){return l(et,function(n){return er(e(n))},n)}),n9=o(function(e,n,r){return l(et,function(n){return l(et,function(r){return er(l(e,n,r))},r)},n)}),re=function(e){return u(n6,n9(D),er(L),e)},rn=r(function(e,n){return ec(l(et,ep(e),n))}),rr=o(function(e,n){return l(n8,function(){return 0},re(l(n7,rn(e),n)))}),ro=o(function(){return er(0)}),rt=r(function(e,n){return l(n8,e,n)});em.Task=ev(n4,rr,ro,rt);var ra,ri=eb("Task"),rc=r(function(e,n){return ri(l(n8,e,n))}),rl=M({bk:500,bl:500,bs:0},l(rc,function(e){var n=e.e8;return l(nL,E(n.fa),E(n.eE))},(ra=function(){var e,n;return{dX:(e=eq.body,n=eq.documentElement,{fa:Math.max(e.scrollWidth,e.offsetWidth,n.scrollWidth,n.offsetWidth,n.clientWidth),eE:Math.max(e.scrollHeight,e.offsetHeight,n.scrollHeight,n.offsetHeight,n.clientHeight)}),e8:{d6:eG.pageXOffset,d7:eG.pageYOffset,fa:eq.documentElement.clientWidth,eE:eq.documentElement.clientHeight}}},eo(function(e){eU(function(){e(er(ra()))})})))),ru=function(e){return{$:1,a:e}},rf=o(function(e,n,r){return{cv:r,dU:n,d_:e}}),rs=er(u(rf,L,nR,0)),rd=function(e){return eo(function(n){var r=e.f;2===r.$&&r.c&&r.c(),e.f=null,n(er(0))})},rm=eo(function(e){e(er(Date.now()))}),rv=eo(function(e){var n=eU(function(){e(er(Date.now()))});return function(){eO(n)}}),rp=o(function(e,n,r){var o=r.dU,t=r.cv,a=M(o,n);return 1===a.a.$?a.b.b?l(et,function(e){return l(et,function(r){return er(u(rf,n,nA(e),r))},rm)},ec(l(et,eg(e),rv))):rs:a.b.b?er(u(rf,n,o,t)):l(et,function(){return rs},rd(a.a.a))}),rg=o(function(e,n,r){var o=r.d_,t=r.cv,a=function(r){return l(ep,e,(0,r.a)(r.$?n-t:n2(n)))};return l(et,function(e){return l(et,function(){return er(u(rf,o,nA(e),n))},re(l(n7,a,o)))},ec(l(et,eg(e),rv)))}),rb=o(function(e,n,r){return e(n(r))});em["Browser.AnimationManager"]=ev(rs,rp,rg,0,r(function(e,n){return n.$?ru(l(rb,e,n.a)):{$:0,a:l(rb,e,n.a)}}));var rh=eb("Browser.AnimationManager"),rC=o(function(e,n,r){return{$:0,a:e,b:n,c:r}}),rx=r(function(e,n){return{dM:n,d_:e}}),rT={$:-2},rM=er(l(rx,L,rT)),rP=function(e){return M(y(e.a?"w_":"d_",e.b),e)},ry=a(function(e,n,r,o,t){return{$:-1,a:e,b:n,c:r,d:o,e:t}}),rL=a(function(e,n,r,o,t){if(-1!==t.$||t.a){if(-1!==o.$||o.a||-1!==o.d.$||o.d.a)return s(ry,e,n,r,o,t);var a=o.d;return i=o.e,s(ry,0,o.b,o.c,s(ry,1,a.b,a.c,a.d,a.e),s(ry,1,n,r,i,t))}var i,c=t.b,l=t.c,u=t.d,f=t.e;return -1!==o.$||o.a?s(ry,e,c,l,s(ry,0,n,r,o,u),f):s(ry,0,n,r,s(ry,1,o.b,o.c,o.d,i=o.e),s(ry,1,c,l,u,f))}),rw=o(function(e,n,r){if(-2===r.$)return s(ry,0,e,n,rT,rT);var o=r.a,t=r.b,a=r.c,i=r.d,c=r.e;switch(l(T,e,t)){case 0:return s(rL,o,t,a,u(rw,e,n,i),c);case 1:return s(ry,o,t,n,i,c);default:return s(rL,o,t,a,i,u(rw,e,n,c))}}),rD=o(function(e,n,r){var o=u(rw,e,n,r);return -1!==o.$||o.a?o:s(ry,1,o.b,o.c,o.d,o.e)}),rN=function(e){return u(nB,r(function(e,n){return u(rD,e.a,e.b,n)}),rT,e)},rS=o(function(e,n,r){for(;;){if(-2===r.$)return n;var o=r.e,t=e,a=u(e,r.b,r.c,u(rS,e,n,r.d));e=t,n=a,r=o}}),r_=i(function(e,n,t,a,i,c){var l=u(rS,o(function(r,o,a){for(;;){var i=a.a,c=a.b;if(i.b){var l=i.a,s=l.a,d=l.b,m=i.b;if(0>x(s,r)){a=M(m,u(e,s,d,c));continue}return x(s,r)>0?M(i,u(t,r,o,c)):M(m,f(n,s,d,o,c))}return M(i,u(t,r,o,c))}}),M(nT(a),c),i),s=l.a,d=l.b;return u(nB,r(function(n,r){return u(e,n.a,n.b,r)}),d,s)}),rz=r(function(e,n){return{c4:n,db:e}}),r$=o(function(e,n,r){return l(n8,function(e){return M(n,e)},u(eZ,r.a?eG:eq,r.b,function(r){return l(eg,e,l(rz,n,r))}))}),rA=r(function(e,n){return u(rS,rD,n,e)}),rR=o(function(e,n,r){var a=o(function(n,r,o){var t=o.c;return P(o.a,o.b,l(D,u(r$,e,n,r),t))}),i=o(function(e,n,r){var o=r.b,t=r.c;return P(l(D,n,r.a),o,t)}),c=t(function(e,n,r,o){var t=o.c;return P(o.a,u(rD,e,n,o.b),t)}),f=l(n7,rP,n),s=d(r_,i,c,a,r.dM,rN(f),P(L,rT,L)),m=s.b,v=s.c;return l(et,function(e){return er(l(rx,f,l(rA,m,rN(e))))},l(et,function(){return re(v)},re(l(n7,rd,s.a))))}),rF=o(function(e,n,r){var o=e(n);return o.$?r:l(D,o.a,r)}),rB=r(function(e,n){return u(n6,rF(e),L,n)}),rk=o(function(e,n,r){var o=n.db,t=n.c4,a=l(rB,function(e){var n=e.b.c;return h(e.a,o)?l(eX,n,t):nR},r.d_);return l(et,function(){return er(r)},re(l(n7,ep(e),a)))}),rE=r(function(e,n){return u(rC,n.a,n.b,l(Y,e,n.c))});em["Browser.Events"]=ev(rM,rR,rk,0,rE);var rV,rj,rH,rI,rW,rO,rU,rY,rq,rG,rZ,rX,rK,rJ,rQ,r0,r3,r1,r2,r4,r5,r6,r7,r8=eb("Browser.Events"),r9=o(function(e,n,r){return r8(u(rC,e,n,r))}),oe={$:2,m:L},on=r(function(e,n){return M(function(e,n){var r={};for(var o in e)r[o]=e[o];for(var o in n)r[o]=n[o];return r}(n,e.$?{bs:n.bs+e.a}:{bk:e.a,bl:e.b}),oe)}),or=r(function(e,n){return function(r){var o=n(r),t=o.b;return e(o.a)(t)}}),oo=t(function(e,n,r,o){return{$:2,a:e,b:n,c:r,d:o}}),ot=t(function(e,n,r,o){return{$:3,a:e,b:n,c:r,d:o}}),oa=t(function(e,n,r,o){return{$:4,a:e,b:n,c:r,d:o}}),oi=t(function(e,n,r,o){return{$:6,a:e,b:n,c:r,d:o}}),oc=t(function(e,n,r,o){return{$:7,a:e,b:n,c:r,d:o}}),ol=t(function(e,n,r,o){return{$:5,a:e,b:n,c:r,d:o}}),ou=t(function(e,n,r,o){return{$:1,a:e,b:n,c:r,d:o}}),of={$:0},os=r(function(e,n){return l(nZ,e,n)}),od=r(function(e,n){return 0>x(e,n)?e:n}),om=r(function(e,n){return l(od,e,n)}),ov=c(function(e,n,r,o,t,a,i,c){for(;;){if(!c.b)return{dA:n,dB:o,dC:a,dD:e,dE:r,dF:t};var u=c.b,f=i(c.a);e=l(om,f.dD,e),n=l(os,f.dA,n),r=l(om,f.dE,r),o=l(os,f.dB,o),t=l(om,f.dF,t),a=l(os,f.dC,a),c=u}}),op=o(function(e,n,r){var o=e(n);return m(ov,o.dD,o.dA,o.dE,o.dB,o.dF,o.dC,e,r)}),og=r(function(e,n){return 1>x(n,e)}),ob=function(e){return e},oh=function(e){return e.d6},oC=function(e){return e.d7},ox=function(e){return e.b5},oT=function(e){var n,r=e.a,o=e.b,t=e.c,a=oh(r),i=oC(r),c=ox(r),u=oh(o),f=oC(o),s=ox(o),d=oh(t),m=oC(t),v=ox(t);return l(og,(n={dA:l(os,a,l(os,u,d)),dB:l(os,i,l(os,f,m)),dC:l(os,c,l(os,s,v)),dD:l(om,a,l(om,u,d)),dE:l(om,i,l(om,f,m)),dF:l(om,c,l(om,s,v))}).dA,n.dD)&&l(og,n.dB,n.dE)&&l(og,n.dC,n.dF)?n:{dA:l(os,n.dD,n.dA),dB:l(os,n.dE,n.dB),dC:l(os,n.dF,n.dC),dD:l(om,n.dD,n.dA),dE:l(om,n.dE,n.dB),dF:l(om,n.dF,n.dC)}},oM=function(e){return new Float64Array([e.d6,e.d7,e.b5])},oP=function(e){return oM(e)},oy=function(e){return oM(e)},oL=r(function(e,n){return{d6:n.d7*e.b5-n.b5*e.d7,d7:n.b5*e.d6-n.d6*e.b5,b5:n.d6*e.d7-n.d7*e.d6}}),ow=r(function(e,n){return{d6:n.d6-e.d6,d7:n.d7-e.d7,b5:n.b5-e.b5}}),oD=function(e){return 0>e?-e:e},oN={d6:0,d7:0,b5:0},oS=r(function(e,n){var r=l(nZ,oD(n.d6),l(nZ,oD(n.d7),oD(n.b5)));if(r){var o=n.b5/r,t=n.d7/r,a=n.d6/r,i=V(a*a+t*t+o*o);return{d6:e*a/i,d7:e*t/i,b5:e*o/i}}return oN})(1),o_=o(function(e,n,r){return oS(l(oL,l(ow,n,r),l(ow,e,n)))}),oz=function(e){var n=e.a,r=e.b,o=e.c,t=oy(u(o_,n,r,o));return P({p:t,bZ:oP(n)},{p:t,bZ:oP(r)},{p:t,bZ:oP(o)})},o$=r(function(e,n){return{$:2,a:e,b:n}})({c1:3,c9:0,dH:4}),oA=o(function(e,n,r){return P(e,n,r)}),oR=r(function(e,n){return e*n}),oF=o(function(e,n,r){return{d6:e,d7:n,b5:r}}),oB=(rq=l(oR,-.5,1),rG=l(oR,-.5,1),rX=u(oF,rZ=l(oR,-.5,1),rG,rq),rJ=u(oF,rZ,rG,rK=l(oR,.5,1)),r0=u(oF,rZ,rQ=l(oR,.5,1),rq),r3=u(oF,rZ,rQ,rK),r2=u(oF,r1=l(oR,.5,1),rG,rq),r4=u(oF,r1,rQ,rq),r5=u(oF,r1,rG,rK),r6=u(oF,r1,rQ,rK),function(e){switch(e.$){case 0:case 8:case 9:default:return e;case 1:return f(ou,e.a,e.b,e.c,1);case 2:return f(oo,e.a,e.b,e.c,1);case 3:return f(ot,e.a,e.b,e.c,1);case 4:return f(oa,e.a,e.b,e.c,1);case 5:return f(ol,e.a,e.b,e.c,1);case 6:return f(oi,e.a,e.b,e.c,1);case 7:return f(oc,e.a,e.b,e.c,1)}}(function(e){if(e.b){var n=e.a,r=e.b,o=o$(l(n7,oz,e));return f(oo,u(op,oT,n,r),e,o,0)}return of}(N([u(oA,rX,r4,r2),u(oA,rX,r0,r4),u(oA,rJ,r5,r6),u(oA,rJ,r6,r3),u(oA,r2,r4,r6),u(oA,r2,r6,r5),u(oA,rX,r3,r0),u(oA,rX,rJ,r3),u(oA,rX,r2,r5),u(oA,rX,r5,rJ),u(oA,r0,r6,r4),u(oA,r0,r3,r6)])))),ok={$:0},oE=o(function(e,n,r){return{$:1,a:e,b:n,c:r}}),oV=o(function(e,n,r){var o=n.a,t=n.b,a=e(n.c),i=e(t),c=e(o),f=oy(u(o_,c,i,a));return l(D,{p:f,bZ:oP(c)},l(D,{p:f,bZ:oP(i)},l(D,{p:f,bZ:oP(a)},r)))}),oj=t(function(e,n,r,o){return 1===n.$||1===r.$||1===o.$?nR:nA(u(e,n.a,r.a,o.a))}),oH=0xffffffff>>>32-nU,oI=o(function(e,n,r){for(;;){var o=l(g,oH&n>>>e,r);if(o.$)return l(g,oH&n,o.a);e-=nU,r=o.a}}),oW=r(function(e,n){var r=n.a,o=n.b,t=n.c,a=n.d;return 0>e||x(e,r)>-1?nR:x(e,r>>>5<<5)>-1?nA(l(g,oH&e,a)):nA(u(oI,o,e,t))}),oO=r(function(e,n){return l(oW,e,n.am)}),oU=o(function(e,n,r){for(;;){var o=l(p,32,e),t=o.a,a=o.b;if(0>x(nG(t),32))return l(nJ,!0,{A:n,m:r,q:t});e=a,n=l(D,nq(t),n),r+=1}}),oY=function(e){return e.b?u(oU,e,L,0):nY},oq=r(function(e,n){for(;;){if(!n.b)return!1;var r=n.b;if(e(n.a))return!0;n=r}}),oG=function(e){return!e},oZ=r(function(e,n){return!l(oq,l(rb,oG,e),n)}),oX=r(function(e,n){return u(n6,r(function(n,r){return e(n)?l(D,n,r):r}),L,n)}),oK=r(function(e,n){var r=e.a,o=function(e){var n=e.a,o=e.b,t=e.c;return n>=0&&0>x(n,r)&&o>=0&&0>x(o,r)&&t>=0&&0>x(t,r)};return l(oZ,o,n)?{E:n,am:e}:{E:l(oX,o,n),am:e}}),oJ=o(function(e,n,r){return{$:3,a:e,b:n,c:r}})({c1:1,c9:3,dH:4}),oQ=r(function(e,n){return M(P(e.d6,e.d7,e.b5),P(n.d6,n.d7,n.b5))}),o0=r(function(e,n){for(;;){if(-2===n.$)return nR;var r=n.c,o=n.d,t=n.e;switch(l(T,e,n.b)){case 0:n=o;continue;case 1:return nA(r);default:n=t;continue}}}),o3=u(eJ,0,0,0),o1=i(function(e,n,r,o,t,a){var i=a.a,c=a.b,u=a.c,f=l(o0,l(oQ,e,n),t);if(f.$){var s={p:o3,bZ:oP(n)},d={p:o3,bZ:oP(e)},m=u+1;return P(l(D,P(r,u,m),l(D,P(r,m,o),i)),l(D,s,l(D,d,c)),u+2)}return P(l(D,P(r,f.a,o),i),c,u)}),o2=a(function(e,n,r,o,t){for(;;){if(!r.b)return M(t.a,nH(t.b));var a=r.a,i=a.a,c=a.b,l=r.b,u=e(a.c),f=e(c),s=e(i),m=o+2,v=o+1,p=e,g=n,b=o+3,h=d(o1,u,s,m,o,n,d(o1,f,u,v,m,n,d(o1,s,f,o,v,n,t)));e=p,n=g,r=l,o=b,t=h}}),o4=a(function(e,n,r,o,t){for(;;){if(!n.b)return P(o,t,r);var a=n.a,i=a.a,c=a.b,f=n.b,s=e(a.c),d=e(c),m=e(i),v=r+2,p=r+1,g=r,b=u(rD,l(oQ,m,s),v,u(rD,l(oQ,s,d),p,u(rD,l(oQ,d,m),g,t)));n=f,r+=3,o=l(D,P(g,p,v),o),t=b}}),o5=o(function(e,n,r){var t,a,i=(a=function(e){var n=e.a,r=e.b,a=e.c;return f(oj,o(function(e,n,r){return P(e,n,r)}),l(oO,n,t),l(oO,r,t),l(oO,a,t))},l(rB,a,(t=r).E)),c=u(n6,oV(n),L,i),d=s(o4,n,i,0,L,rT),m=s(o2,n,d.b,i,0,P(d.a,L,d.c)),v=m.a,p=m.b,g=p.b?y(c,p):c;return u(oE,e,l(oK,oY(g),v),l(oJ,g,v))}),o6=r(function(e,n){return n.b?u(n6,D,n,e):e}),o7=function(e){return u(n6,o6,L,e)},o8=function(e){var n;switch(e.$){case 0:case 8:case 9:default:return ok;case 1:case 2:return u(o5,e.a,n2,{E:l(n7,function(e){return P(3*e,3*e+1,3*e+2)},l(nV,0,nk(n=l(n7,ob,e.b))-1)),am:oY(o7(l(n7,function(e){return N([e.a,e.b,e.c])},n)))});case 3:return u(o5,e.a,n2,e.b);case 4:case 5:case 6:case 7:return u(o5,e.a,function(e){return e.bZ},e.b)}}(oB),o9={$:0},te=function(e){return{$:4,a:e}},tn=r(function(e,n){for(;;){if(!e.b)return n;var r=e.a;e=e.b,n=l(D,r,n)}}),tr=function(e){return te(l(tn,e,L))},to=r(function(e,n){return{$:1,a:e,b:n}}),tt={src:"\n        precision mediump float;\n        \n        uniform mediump sampler2D colorTexture;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        void main () {\n            gl_FragColor = texture2D(colorTexture, interpolatedUv);\n        }\n    ",attributes:{},uniforms:{colorTexture:"bH"}},ta=r(function(e,n){switch(n.$){case 0:return l(nd,e,n);case 1:return l(nm,e,n);case 2:return l(nv,e,n);case 3:return l(np,e,n);case 4:return l(ng,e,n);default:return l(nb,e,n)}}),ti=r(function(e,n){switch(n.$){case 0:return l(e6,e,n);case 1:return l(e7,e,n);case 2:return l(e8,e,n);case 3:return l(e9,e,n);case 4:return l(ne,e,n);case 5:return l(nn,e,n);case 6:return l(nr,e,n);case 7:return l(no,e,n);default:var r;return void((r=e.sampleAlphaToCoverage).toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SAMPLE_ALPHA_TO_COVERAGE),r.enabled=!0))}}),tc=function(e){return{$:5,a:e}},tl=tc(1029),tu=tc(1028),tf=o(function(e,n,r){return 1===n?l(D,e?tl:tu,r):r}),ts={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute mediump vec2 uv;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main() {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedUv = uv;\n        }\n    ",attributes:{position:"bZ",uv:"M"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},td=t(function(e,n,r,o){return l(to,n,c(function(n,t,a,i,c,l,f,d){return s(e5,u(tf,i,o,d),ts,tt,r,{bH:e,b:a,c:t,d:l,e:n,f:c})}))}),tm={src:"\n        precision lowp float;\n        \n        uniform lowp vec3 constantColor;\n        \n        void main () {\n            gl_FragColor = vec4(constantColor, 1.0);\n        }\n    ",attributes:{},uniforms:{constantColor:"aD"}},tv={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n        }\n    ",attributes:{position:"bZ"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},tp=t(function(e,n,r,o){return l(to,n,c(function(n,t,a,i,c,l,f,d){return s(e5,u(tf,i,o,d),tv,tm,r,{aD:e,b:a,c:t,d:l,e:n,f:c})}))}),tg=r(function(e,n){return{$:3,a:e,b:n}}),tb={src:"\n        precision lowp float;\n        \n        uniform lowp vec3 constantColor;\n        uniform lowp float pointRadius;\n        uniform highp mat4 sceneProperties;\n        \n        float pointAlpha(float pointRadius, vec2 pointCoord) {\n            float pointSize = 2.0 * pointRadius;\n            float x = (pointSize + 2.0) * (pointCoord.s - 0.5);\n            float y = (pointSize + 2.0) * (pointCoord.t - 0.5);\n            float r = sqrt(x * x + y * y);\n            float innerRadius = pointRadius;\n            float outerRadius = pointRadius + 1.0;\n            if (r > outerRadius) {\n                return 0.0;\n            } else if (r > innerRadius) {\n                return outerRadius - r;\n            } else {\n                return 1.0;\n            }\n        }\n        \n        void main () {\n            float supersampling = sceneProperties[3][0];\n            float alpha = pointAlpha(pointRadius * supersampling, gl_PointCoord);\n            gl_FragColor = vec4(constantColor, alpha);\n        }\n    ",attributes:{},uniforms:{constantColor:"aD",pointRadius:"bY",sceneProperties:"e"}},th={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform lowp float pointRadius;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            float supersampling = sceneProperties[3][0];\n            gl_PointSize = 2.0 * pointRadius * supersampling + 2.0;\n        }\n    ",attributes:{position:"bZ"},uniforms:{modelMatrix:"b",modelScale:"c",pointRadius:"bY",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},tC=t(function(e,n,r,o){return l(tg,r,c(function(r,t,a,i,c,l,u,f){return s(e5,f,th,tb,o,{aD:e,b:a,c:t,bY:n,d:l,e:r,f:c})}))}),tx={src:"\n        precision mediump float;\n        \n        uniform mediump vec3 emissiveColor;\n        uniform highp mat4 sceneProperties;\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main () {\n            gl_FragColor = toSrgb(emissiveColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{emissiveColor:"aO",sceneProperties:"e"}},tT=a(function(e,n,r,o,t){return l(to,r,c(function(r,a,i,c,f,d,m,v){return s(e5,u(tf,c,t,v),tv,tx,o,{aO:l(eQ,n,e),b:i,c:a,d:d,e:r,f:f})}))}),tM={src:"\n        precision mediump float;\n        \n        uniform mediump vec3 emissiveColor;\n        uniform lowp float pointRadius;\n        uniform highp mat4 sceneProperties;\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        float pointAlpha(float pointRadius, vec2 pointCoord) {\n            float pointSize = 2.0 * pointRadius;\n            float x = (pointSize + 2.0) * (pointCoord.s - 0.5);\n            float y = (pointSize + 2.0) * (pointCoord.t - 0.5);\n            float r = sqrt(x * x + y * y);\n            float innerRadius = pointRadius;\n            float outerRadius = pointRadius + 1.0;\n            if (r > outerRadius) {\n                return 0.0;\n            } else if (r > innerRadius) {\n                return outerRadius - r;\n            } else {\n                return 1.0;\n            }\n        }\n        \n        void main () {\n            vec4 color = toSrgb(emissiveColor, sceneProperties);\n            float supersampling = sceneProperties[3][0];\n            float alpha = pointAlpha(pointRadius * supersampling, gl_PointCoord);\n            gl_FragColor = vec4(color.rgb, alpha);\n        }\n    ",attributes:{},uniforms:{emissiveColor:"aO",pointRadius:"bY",sceneProperties:"e"}},tP=a(function(e,n,r,o,t){return l(tg,o,c(function(o,a,i,c,u,f,d,m){return s(e5,m,th,tM,t,{aO:l(eQ,n,e),b:i,c:a,bY:r,d:f,e:o,f:u})}))}),ty={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform lowp vec3 materialColor;\n        uniform highp mat4 viewMatrix;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 lambertianLight(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                vec3 upDirection = xyz_type.xyz;\n                vec3 aboveLuminance = rgb_parameter.rgb;\n                vec3 belowLuminance = rgb_parameter.a * aboveLuminance;\n                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, surfaceNormal);\n                return luminance * materialColor;\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(\n                xyz_type,\n                rgb_parameter,\n                surfacePosition,\n                directionToLight,\n                normalIlluminance\n            );\n        \n            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);\n            return (normalIlluminance * dotNL) * (materialColor / kPi);\n        }\n        \n        vec3 lambertianLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            vec3 litColor1 = enabledLights[0] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[0], lights12[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[2], lights12[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[0], lights34[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[2], lights34[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[0], lights56[1]);\n            vec3 litColor6 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[2], lights56[3]);\n            vec3 litColor7 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[0], lights78[1]);\n            vec3 litColor8 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[2], lights78[3]);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 normalDirection = normalize(interpolatedNormal) * getNormalSign();\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = lambertianLighting(\n                interpolatedPosition,\n                normalDirection,\n                materialColor,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{enabledLights:"T",lights12:"bd",lights34:"bP",lights56:"bQ",lights78:"bR",materialColor:"co",sceneProperties:"e",viewMatrix:"f"}},tL={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute highp vec3 normal;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n        }\n    ",attributes:{normal:"p",position:"bZ"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},tw=t(function(e,n,r,o){return l(to,n,c(function(n,t,a,i,c,l,f,d){var m=f.a,v=f.b;return s(e5,u(tf,i,o,d),tL,ty,r,{T:v,bd:m.bd,bP:m.bP,bQ:m.bQ,bR:m.bR,co:e,b:a,c:t,d:l,e:n,f:c})}))}),tD={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform mediump sampler2D materialColorTexture;\n        uniform mediump sampler2D normalMapTexture;\n        uniform lowp float useNormalMap;\n        uniform highp mat4 viewMatrix;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {\n            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);\n            float x = 2.0 * (rgb.r - 0.5);\n            float y = 2.0 * (rgb.g - 0.5);\n            float z = 2.0 * (rgb.b - 0.5);\n            return normalize(vec3(-x, -y, z));\n        }\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getMappedNormal(vec3 normal, vec3 tangent, float normalSign, vec3 localNormal) {\n            vec3 bitangent = cross(normal, tangent) * normalSign;\n            return normalize(localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal);\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 lambertianLight(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                vec3 upDirection = xyz_type.xyz;\n                vec3 aboveLuminance = rgb_parameter.rgb;\n                vec3 belowLuminance = rgb_parameter.a * aboveLuminance;\n                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, surfaceNormal);\n                return luminance * materialColor;\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(\n                xyz_type,\n                rgb_parameter,\n                surfacePosition,\n                directionToLight,\n                normalIlluminance\n            );\n        \n            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);\n            return (normalIlluminance * dotNL) * (materialColor / kPi);\n        }\n        \n        vec3 lambertianLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            vec3 litColor1 = enabledLights[0] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[0], lights12[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[2], lights12[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[0], lights34[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[2], lights34[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[0], lights56[1]);\n            vec3 litColor6 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[2], lights56[3]);\n            vec3 litColor7 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[0], lights78[1]);\n            vec3 litColor8 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[2], lights78[3]);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);\n            float normalSign = getNormalSign();\n            vec3 originalNormal = normalize(interpolatedNormal) * normalSign;\n            vec3 normalDirection = getMappedNormal(originalNormal, interpolatedTangent, normalSign, localNormal);\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n            vec3 materialColor = fromSrgb(texture2D(materialColorTexture, interpolatedUv).rgb);\n        \n            vec3 linearColor = lambertianLighting(\n                interpolatedPosition,\n                normalDirection,\n                materialColor,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{enabledLights:"T",lights12:"bd",lights34:"bP",lights56:"bQ",lights78:"bR",materialColorTexture:"cp",normalMapTexture:"aV",sceneProperties:"e",useNormalMap:"a_",viewMatrix:"f"}},tN={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute highp vec3 normal;\n        attribute mediump vec2 uv;\n        attribute highp vec3 tangent;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        vec3 getWorldTangent(vec3 modelTangent, vec4 modelScale, mat4 modelMatrix) {\n            return (modelMatrix * vec4(safeNormalize(modelScale.xyz * modelTangent), 0.0)).xyz;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n            interpolatedUv = uv;\n            interpolatedTangent = getWorldTangent(tangent, modelScale, modelMatrix);\n        }\n    ",attributes:{normal:"p",position:"bZ",tangent:"d1",uv:"M"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},tS=i(function(e,n,r,o,t,a){return l(to,o,c(function(o,i,c,l,f,d,m,v){var p=m.a,g=m.b;return s(e5,u(tf,l,a,v),tN,tD,t,{T:g,bd:p.bd,bP:p.bP,bQ:p.bQ,bR:p.bR,cp:e,b:c,c:i,aV:n,d:d,e:o,a_:r,f:f})}))}),t_={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform mediump sampler2D baseColorTexture;\n        uniform lowp vec4 constantBaseColor;\n        uniform mediump sampler2D roughnessTexture;\n        uniform lowp vec2 constantRoughness;\n        uniform mediump sampler2D metallicTexture;\n        uniform lowp vec2 constantMetallic;\n        uniform mediump sampler2D normalMapTexture;\n        uniform lowp float useNormalMap;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const mediump float kMediumpFloatMax = 65504.0;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getFloatValue(sampler2D texture, vec2 uv, vec2 constantValue) {\n            if (constantValue.y == 1.0) {\n                return constantValue.x;\n            } else {\n                vec4 textureColor = texture2D(texture, uv);\n                return dot(textureColor, vec4(0.2126, 0.7152, 0.0722, 0.0));\n            }\n        }\n        \n        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {\n            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);\n            float x = 2.0 * (rgb.r - 0.5);\n            float y = 2.0 * (rgb.g - 0.5);\n            float z = 2.0 * (rgb.b - 0.5);\n            return normalize(vec3(-x, -y, z));\n        }\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getMappedNormal(vec3 normal, vec3 tangent, float normalSign, vec3 localNormal) {\n            vec3 bitangent = cross(normal, tangent) * normalSign;\n            return normalize(localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal);\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)\n        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {\n            vec3 crossNH = cross(normalDirection, halfDirection);\n            float a = dotNH * alpha;\n            float k = alpha / (dot(crossNH, crossNH) + a * a);\n            float d = k * k * (1.0 / kPi);\n            return min(d, kMediumpFloatMax);\n        }\n        \n        float safeQuotient(float numerator, float denominator) {\n            if (denominator == 0.0) {\n                return 0.0;\n            } else {\n                return numerator / denominator;\n            }\n        }\n        \n        float g1(float dotNV, float alphaSquared) {\n            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));\n        }\n        \n        float specularG(float dotNL, float dotNV, float alphaSquared) {\n            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);\n        }\n        \n        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {\n            vec3 one = vec3(1.0, 1.0, 1.0);\n            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\n            return specularBaseColor + (one - specularBaseColor) * scale;\n        }\n        \n        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {\n            vec3 halfDirection = normalize(directionToCamera + directionToLight);\n            float dotVH = positiveDotProduct(directionToCamera, halfDirection);\n            float dotNH = positiveDotProduct(normalDirection, halfDirection);\n            float dotNHSquared = dotNH * dotNH;\n        \n            float d = specularD(alpha, dotNH, normalDirection, halfDirection);\n            float g = specularG(dotNL, dotNV, alpha * alpha);\n            vec3 f = fresnelColor(specularBaseColor, dotVH);\n            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;\n        }\n        \n        vec3 sampleFacetNormal(vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {\n            float t2 = (1.0 - s);\n            vec3 vNh = t2 * vT2 + sqrt(max(0.0, 1.0 - t2 * t2)) * vH;\n            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 softLightingSpecularSample(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localViewDirection,\n            vec3 localLightDirection,\n            vec3 localHalfDirection,\n            float alphaSquared,\n            vec3 specularBaseColor\n        ) {\n            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);\n            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);\n            float dotNL = localLightDirection.z;\n            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));\n        }\n        \n        vec3 softLighting(\n            vec3 normalDirection,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha,\n            vec3 directionToCamera,\n            vec3 viewY,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float alphaSquared = alpha * alpha;\n            vec3 upDirection = xyz_type.xyz;\n            vec3 luminanceAbove = rgb_parameter.rgb;\n            vec3 luminanceBelow = rgb_parameter.a * luminanceAbove;\n            vec3 crossProduct = cross(normalDirection, directionToCamera);\n            float crossMagnitude = length(crossProduct);\n            vec3 xDirection = vec3(0.0, 0.0, 0.0);\n            vec3 yDirection = vec3(0.0, 0.0, 0.0);\n            if (crossMagnitude > 1.0e-6) {\n                yDirection = (1.0 / crossMagnitude) * crossProduct;\n                xDirection = cross(yDirection, normalDirection);\n            } else {\n                vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n                xDirection = normalize(cross(viewY, normalDirection));\n                yDirection = cross(normalDirection, xDirection);\n            }\n            float localViewX = dot(directionToCamera, xDirection);\n            float localViewZ = dot(directionToCamera, normalDirection);\n            vec3 localViewDirection = vec3(localViewX, 0, localViewZ);\n            float localUpX = dot(upDirection, xDirection);\n            float localUpY = dot(upDirection, yDirection);\n            float localUpZ = dot(upDirection, normalDirection);\n            vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);\n        \n            vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));\n            vec3 vT1 = vec3(0.0, 1.0, 0.0);\n            vec3 vT2 = cross(vH, vT1);\n            float s = 0.5 * (1.0 + vH.z);\n            \n            vec3 localHalfDirection = sampleFacetNormal(vH, vT1, vT2, s, alpha);\n            vec3 localLightDirection = vec3(0.0, 0.0, 0.0);\n            \n            localLightDirection = -reflect(localViewDirection, localHalfDirection);\n            vec3 specular = softLightingSpecularSample(luminanceAbove, luminanceBelow, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);\n            \n            localLightDirection = vec3(0.000000, 0.000000, 1.000000);\n            vec3 diffuse = softLightingLuminance(luminanceAbove, luminanceBelow, localUpDirection, localLightDirection) * localLightDirection.z;\n            \n            return specular + diffuse * diffuseBaseColor;\n        }\n        \n        vec3 physicalLight(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            vec3 normalDirection,\n            vec3 directionToCamera,\n            vec3 viewY,\n            float dotNV,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                return softLighting(normalDirection, diffuseBaseColor, specularBaseColor, alpha, directionToCamera, viewY, xyz_type, rgb_parameter);\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_parameter, surfacePosition, directionToLight, normalIlluminance);\n        \n            float dotNL = positiveDotProduct(normalDirection, directionToLight);\n            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);\n            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);\n        }\n        \n        vec3 physicalLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 baseColor,\n            vec3 directionToCamera,\n            mat4 viewMatrix,\n            float roughness,\n            float metallic,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);\n            float alpha = roughness * roughness;\n            float nonmetallic = 1.0 - metallic;\n            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;\n            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;\n            vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n        \n            vec3 litColor1 = enabledLights[0] == 1.0 ? physicalLight(lights12[0], lights12[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? physicalLight(lights12[2], lights12[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? physicalLight(lights34[0], lights34[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? physicalLight(lights34[2], lights34[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = physicalLight(lights56[0], lights56[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor6 = physicalLight(lights56[2], lights56[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor7 = physicalLight(lights78[0], lights78[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor8 = physicalLight(lights78[2], lights78[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 baseColor = fromSrgb(texture2D(baseColorTexture, interpolatedUv).rgb) * (1.0 - constantBaseColor.w) + constantBaseColor.rgb * constantBaseColor.w;\n            float roughness = getFloatValue(roughnessTexture, interpolatedUv, constantRoughness);\n            float metallic = getFloatValue(metallicTexture, interpolatedUv, constantMetallic);\n        \n            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);\n            float normalSign = getNormalSign();\n            vec3 originalNormal = normalize(interpolatedNormal) * normalSign;\n            vec3 normalDirection = getMappedNormal(originalNormal, interpolatedTangent, normalSign, localNormal);\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = physicalLighting(\n                interpolatedPosition,\n                normalDirection,\n                baseColor,\n                directionToCamera,\n                viewMatrix,\n                roughness,\n                metallic,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{baseColorTexture:"b8",constantBaseColor:"ca",constantMetallic:"cb",constantRoughness:"cc",enabledLights:"T",lights12:"bd",lights34:"bP",lights56:"bQ",lights78:"bR",metallicTexture:"cs",normalMapTexture:"aV",roughnessTexture:"cM",sceneProperties:"e",useNormalMap:"a_",viewMatrix:"f"}},tz={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform lowp vec3 baseColor;\n        uniform lowp float roughness;\n        uniform lowp float metallic;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const mediump float kMediumpFloatMax = 65504.0;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)\n        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {\n            vec3 crossNH = cross(normalDirection, halfDirection);\n            float a = dotNH * alpha;\n            float k = alpha / (dot(crossNH, crossNH) + a * a);\n            float d = k * k * (1.0 / kPi);\n            return min(d, kMediumpFloatMax);\n        }\n        \n        float safeQuotient(float numerator, float denominator) {\n            if (denominator == 0.0) {\n                return 0.0;\n            } else {\n                return numerator / denominator;\n            }\n        }\n        \n        float g1(float dotNV, float alphaSquared) {\n            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));\n        }\n        \n        float specularG(float dotNL, float dotNV, float alphaSquared) {\n            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);\n        }\n        \n        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {\n            vec3 one = vec3(1.0, 1.0, 1.0);\n            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\n            return specularBaseColor + (one - specularBaseColor) * scale;\n        }\n        \n        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {\n            vec3 halfDirection = normalize(directionToCamera + directionToLight);\n            float dotVH = positiveDotProduct(directionToCamera, halfDirection);\n            float dotNH = positiveDotProduct(normalDirection, halfDirection);\n            float dotNHSquared = dotNH * dotNH;\n        \n            float d = specularD(alpha, dotNH, normalDirection, halfDirection);\n            float g = specularG(dotNL, dotNV, alpha * alpha);\n            vec3 f = fresnelColor(specularBaseColor, dotVH);\n            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;\n        }\n        \n        vec3 sampleFacetNormal(vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {\n            float t2 = (1.0 - s);\n            vec3 vNh = t2 * vT2 + sqrt(max(0.0, 1.0 - t2 * t2)) * vH;\n            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 softLightingSpecularSample(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localViewDirection,\n            vec3 localLightDirection,\n            vec3 localHalfDirection,\n            float alphaSquared,\n            vec3 specularBaseColor\n        ) {\n            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);\n            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);\n            float dotNL = localLightDirection.z;\n            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));\n        }\n        \n        vec3 softLighting(\n            vec3 normalDirection,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha,\n            vec3 directionToCamera,\n            vec3 viewY,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float alphaSquared = alpha * alpha;\n            vec3 upDirection = xyz_type.xyz;\n            vec3 luminanceAbove = rgb_parameter.rgb;\n            vec3 luminanceBelow = rgb_parameter.a * luminanceAbove;\n            vec3 crossProduct = cross(normalDirection, directionToCamera);\n            float crossMagnitude = length(crossProduct);\n            vec3 xDirection = vec3(0.0, 0.0, 0.0);\n            vec3 yDirection = vec3(0.0, 0.0, 0.0);\n            if (crossMagnitude > 1.0e-6) {\n                yDirection = (1.0 / crossMagnitude) * crossProduct;\n                xDirection = cross(yDirection, normalDirection);\n            } else {\n                vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n                xDirection = normalize(cross(viewY, normalDirection));\n                yDirection = cross(normalDirection, xDirection);\n            }\n            float localViewX = dot(directionToCamera, xDirection);\n            float localViewZ = dot(directionToCamera, normalDirection);\n            vec3 localViewDirection = vec3(localViewX, 0, localViewZ);\n            float localUpX = dot(upDirection, xDirection);\n            float localUpY = dot(upDirection, yDirection);\n            float localUpZ = dot(upDirection, normalDirection);\n            vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);\n        \n            vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));\n            vec3 vT1 = vec3(0.0, 1.0, 0.0);\n            vec3 vT2 = cross(vH, vT1);\n            float s = 0.5 * (1.0 + vH.z);\n            \n            vec3 localHalfDirection = sampleFacetNormal(vH, vT1, vT2, s, alpha);\n            vec3 localLightDirection = vec3(0.0, 0.0, 0.0);\n            \n            localLightDirection = -reflect(localViewDirection, localHalfDirection);\n            vec3 specular = softLightingSpecularSample(luminanceAbove, luminanceBelow, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);\n            \n            localLightDirection = vec3(0.000000, 0.000000, 1.000000);\n            vec3 diffuse = softLightingLuminance(luminanceAbove, luminanceBelow, localUpDirection, localLightDirection) * localLightDirection.z;\n            \n            return specular + diffuse * diffuseBaseColor;\n        }\n        \n        vec3 physicalLight(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            vec3 normalDirection,\n            vec3 directionToCamera,\n            vec3 viewY,\n            float dotNV,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                return softLighting(normalDirection, diffuseBaseColor, specularBaseColor, alpha, directionToCamera, viewY, xyz_type, rgb_parameter);\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_parameter, surfacePosition, directionToLight, normalIlluminance);\n        \n            float dotNL = positiveDotProduct(normalDirection, directionToLight);\n            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);\n            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);\n        }\n        \n        vec3 physicalLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 baseColor,\n            vec3 directionToCamera,\n            mat4 viewMatrix,\n            float roughness,\n            float metallic,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);\n            float alpha = roughness * roughness;\n            float nonmetallic = 1.0 - metallic;\n            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;\n            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;\n            vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n        \n            vec3 litColor1 = enabledLights[0] == 1.0 ? physicalLight(lights12[0], lights12[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? physicalLight(lights12[2], lights12[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? physicalLight(lights34[0], lights34[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? physicalLight(lights34[2], lights34[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = physicalLight(lights56[0], lights56[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor6 = physicalLight(lights56[2], lights56[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor7 = physicalLight(lights78[0], lights78[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor8 = physicalLight(lights78[2], lights78[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 normalDirection = normalize(interpolatedNormal) * getNormalSign();\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = physicalLighting(\n                interpolatedPosition,\n                normalDirection,\n                baseColor,\n                directionToCamera,\n                viewMatrix,\n                roughness,\n                metallic,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{baseColor:"ee",enabledLights:"T",lights12:"bd",lights34:"bP",lights56:"bQ",lights78:"bR",metallic:"cr",roughness:"eX",sceneProperties:"e",viewMatrix:"f"}},t$=i(function(e,n,r,o,t,a){return l(to,o,c(function(o,i,c,l,f,d,m,v){var p=m.a,g=m.b;return s(e5,u(tf,l,a,v),tL,tz,t,{ee:e,T:g,bd:p.bd,bP:p.bP,bQ:p.bQ,bR:p.bR,cr:r,b:c,c:i,d:d,eX:n,e:o,f:f})}))}),tA=r(function(e,n){return{$:1,a:e,b:n}}),tR=r(function(e,n){return n.$?M(n.a.D,1):M(e,0)}),tF=function(e){return e[0]},tB=function(e){return e[1]},tk=function(e){return e[2]},tE=f(e0,0,0,0,0),tV=r(function(e,n){var r;return n.$?M(n.a.D,tE):M(e,f(e0,tF(r=n.a),tB(r),tk(r),1))}),tj=r(function(e,n){var r,o=M(e,n);return o.a.$?l(tA,M(r=o.a.a.D,tE),l(tR,r,n)):o.b.$?l(tA,l(tV,r=o.b.a.D,e),l(tR,r,n)):{$:0,a:o.a.a}}),tH=o(function(e,n,r){return{$:0,a:e,b:n,c:r}}),tI=t(function(e,n,r,o){return{$:1,a:e,b:n,c:r,d:o}}),tW=t(function(e,n,r,o){return{$:0,a:e,b:n,c:r,d:o}}),tO=l(eK,0,0),tU=r(function(e,n){return n.$?M(n.a.D,tO):M(e,l(eK,n.a,1))}),tY=t(function(e,n,r,o){var t,a=f(tW,e,n,r,o);return a.a.$?f(tI,M(t=a.a.a.D,tE),l(tU,t,n),l(tU,t,r),l(tR,t,o)):a.b.$?f(tI,l(tV,t=a.b.a.D,e),M(t,tO),l(tU,t,r),l(tR,t,o)):a.c.$?f(tI,l(tV,t=a.c.a.D,e),l(tU,t,n),M(t,tO),l(tR,t,o)):a.d.$?f(tI,l(tV,t=a.d.a.D,e),l(tU,t,n),l(tU,t,r),M(t,1)):u(tH,a.a.a,a.b.a,a.c.a)}),tq={src:"\n        precision mediump float;\n        \n        uniform mediump sampler2D colorTexture;\n        uniform mediump float backlight;\n        uniform highp mat4 sceneProperties;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main () {\n            vec3 emissiveColor = fromSrgb(texture2D(colorTexture, interpolatedUv).rgb) * backlight;\n            gl_FragColor = toSrgb(emissiveColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{backlight:"b6",colorTexture:"bH",sceneProperties:"e"}},tG=a(function(e,n,r,o,t){return l(to,r,c(function(r,a,i,c,l,f,d,m){return s(e5,u(tf,c,t,m),ts,tq,o,{b6:n,bH:e,b:i,c:a,d:f,e:r,f:l})}))}),tZ={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute highp vec3 normal;\n        attribute mediump vec2 uv;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n            interpolatedUv = uv;\n            interpolatedTangent = vec3(0.0, 0.0, 0.0);\n        }\n    ",attributes:{normal:"p",position:"bZ",uv:"M"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},tX=t(function(e,n,r,o){return l(to,n,c(function(n,t,a,i,c,l,f,d){var m=f.a,v=f.b;return s(e5,u(tf,i,o,d),tZ,tD,r,{T:v,bd:m.bd,bP:m.bP,bQ:m.bQ,bR:m.bR,cp:e,b:a,c:t,aV:e,d:l,e:n,a_:0,f:c})}))}),tK=n(9,rV=function(e,n,r,o,t,a,i,f,d){return l(to,i,c(function(i,c,l,m,v,p,g,b){var h=g.a,C=g.b;return s(e5,u(tf,m,d,b),tZ,t_,f,{b8:e,ca:n,cb:a,cc:o,T:C,bd:h.bd,bP:h.bP,bQ:h.bQ,bR:h.bR,cs:t,b:l,c:c,aV:e,d:p,cM:r,e:i,a_:0,f:v})}))},function(e){return function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return function(c){return function(l){return rV(e,n,r,o,t,a,i,c,l)}}}}}}}}}),tJ=o(function(e,n,r){return r>.5?n+(1-r)*(e-n):e+r*(n-e)}),tQ=function(e){return e.dC},t0=function(e){return e.dF},t3=r(function(e,n){return n-e}),t1=function(e){return P(l(t3,e.dD,e.dA),l(t3,e.dE,e.dB),l(t3,t0(e),tQ(e)))},t2=function(e){var n,r=t1(e),o=r.a,t=r.b,a=r.c;return{ei:u(oF,u(tJ,(n=e).dD,n.dA,.5),u(tJ,n.dE,n.dB,.5),u(tJ,n.dF,n.dC,.5)),eB:o/2,eC:t/2,eD:a/2}},t4=r(function(e,n){switch(e.$){case 0:if(e.b.$){var r=e.b.a.D;switch(n.$){case 0:case 1:case 2:case 3:case 4:case 8:case 9:default:return o9;case 5:case 6:case 7:return t=n.c,a=n.d,f(td,r,t2(B=n.a),t,a)}}else{var o=e.b.a;switch(n.$){case 0:return o9;case 1:var t=n.c,a=n.d;return f(tp,o,t2(B=n.a),t,a);case 2:case 3:case 4:case 5:case 6:case 7:return t=n.c,a=n.d,f(tp,o,t2(B=n.a),t,a);case 8:case 9:return t=n.c,f(tp,o,t2(B=n.a),t,0);default:return t=n.d,f(tC,o,n.b,t2(B=n.a),t)}}case 1:if(e.b.$)switch(r=e.b.a.D,m=e.c,n.$){case 0:case 1:case 2:case 3:case 4:case 8:case 9:default:return o9;case 5:case 6:case 7:return t=n.c,a=n.d,s(tG,r,m,t2(B=n.a),t,a)}else{var i=e.b.a,m=e.c;switch(n.$){case 0:return o9;case 1:case 2:case 3:case 4:case 5:case 6:case 7:return t=n.c,a=n.d,s(tT,i,m,t2(B=n.a),t,a);case 8:case 9:return t=n.c,s(tT,i,m,t2(B=n.a),t,0);default:return t=n.d,s(tP,i,m,n.b,t2(B=n.a),t)}}case 2:var v=l(tj,e.b,e.c);if(v.$){var p=v.a.a,g=v.b,b=g.a,h=g.b;switch(n.$){case 0:case 1:case 2:case 3:case 4:case 5:case 8:case 9:default:return o9;case 6:return t=n.c,x=n.d,f(tX,p,t2(B=n.a),t,x);case 7:return t=n.c,x=n.d,d(tS,p,b,h,t2(B=n.a),t,x)}}else{var C=v.a;switch(n.$){case 0:case 1:case 3:case 5:case 8:case 9:default:return o9;case 2:t=n.c;var x=n.d;return f(tw,C,t2(B=n.a),t,x);case 4:case 6:case 7:return t=n.c,x=n.d,f(tw,C,t2(B=n.a),t,x)}}default:var T=f(tY,e.b,e.c,e.d,e.e);if(T.$){var M,P,y,L,w=T.a,D=w.a,N=w.b,S=T.b,_=S.a,z=S.b,$=T.c,A=$.a,R=$.b,F=T.d;switch(b=F.a,h=F.b,n.$){case 0:case 1:case 2:case 3:case 4:case 5:case 8:case 9:default:return o9;case 6:return t=n.c,a=n.d,P=t2(B=n.a),y=t,L=a,9===tK.a?tK.f(D,N,_,z,A,R,P,y,L):tK(D)(N)(_)(z)(A)(R)(P)(y)(L);case 7:;return B=n.a,t=n.c,a=n.d,(M=_,function(e){return function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return function(f){return l(to,a,c(function(a,c,l,d,m,v,p,g){var b=p.a,h=p.b;return s(e5,u(tf,d,f,g),tN,t_,i,{b8:D,ca:N,cb:r,cc:e,T:h,bd:b.bd,bP:b.bP,bQ:b.bQ,bR:b.bR,cs:n,b:l,c:c,aV:o,d:v,cM:M,e:a,a_:t,f:m})}))}}}}}}}})(z)(A)(R)(b)(h)(t2(B))(t)(a)}}else{var B,k=T.a,E=T.b,V=T.c;switch(n.$){case 0:case 1:case 3:case 5:case 8:case 9:default:return o9;case 2:case 4:case 6:case 7:return t=n.c,a=n.d,d(t$,k,E,V,t2(B=n.a),t,a)}}}}),t5=function(e){return e.d6},t6=function(e){return e.d7},t7=function(e){return e.b5},t8=function(e){var n=t7(e.cX),r=t6(e.cX),o=t5(e.cX),t=t7(e.cW),a=t6(e.cW),i=t5(e.cW),c=t7(e.cV),l=t6(e.cV),u=t5(e.cV);return u*a*n+l*t*o+c*i*r-c*a*o-l*i*n-u*t*r>0},t9=function(e){return e.cw},ae=function(e){return e.cV},an=function(e){return e.cW},ar=function(e){return e.cX},ao=r(function(e,n){return{$:5,a:e,b:n}}),at=r(function(e,n){return{da:h(e.da,n.da),r:e.r*n.r+e.s*n.u+e.t*n.x,s:e.r*n.s+e.s*n.v+e.t*n.y,t:e.r*n.t+e.s*n.w+e.t*n.z,u:e.u*n.r+e.v*n.u+e.w*n.x,v:e.u*n.s+e.v*n.v+e.w*n.y,w:e.u*n.t+e.v*n.w+e.w*n.z,x:e.x*n.r+e.y*n.u+e.z*n.x,y:e.x*n.s+e.y*n.v+e.z*n.y,z:e.x*n.t+e.y*n.w+e.z*n.z,I:n.I+(e.I*n.r+e.J*n.u+e.K*n.x)*n.b2,J:n.J+(e.I*n.s+e.J*n.v+e.K*n.y)*n.b2,K:n.K+(e.I*n.t+e.J*n.w+e.K*n.z)*n.b2,b2:e.b2*n.b2}}),aa=r(function(e,n){switch(n.$){case 0:return o9;case 5:var r=n.b;return l(ao,l(at,n.a,e),r);default:return l(ao,e,n)}}),ai=r(function(e,n){var r,o,t,a;return l(aa,(r=t9(e),o=ar(e),t=an(e),a=ae(e),{da:t8(e),r:a.d6,s:a.d7,t:a.b5,u:t.d6,v:t.d7,w:t.b5,x:o.d6,y:o.d7,z:o.b5,I:r.d6,J:r.d7,K:r.b5,b2:1}),n)}),ac=function(e){return{$:2,a:e}},al=r(function(e,n){var r=e.a,o=e.b,t=e.c,a=n.ei;return{ei:{d6:r*a.d6,d7:o*a.d7,b5:t*a.b5},eB:r*n.eB,eC:o*n.eC,eD:t*n.eD}}),au=function(e){return function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return function(c){return function(l){return function(u){var f,s={d6:o[0],d7:o[1],b5:o[2],d5:o[3]};return m(n,r,new Float64Array([(f={d5:s.d5,d6:s.d6*e.a,d7:s.d7*e.b,b5:s.b5*e.c}).d6,f.d7,f.b5,f.d5]),t,a,i,c,l,u)}}}}}}}}}},af=r(function(e,n){switch(n.$){case 0:return o9;case 5:return l(ao,n.a,l(af,e,n.b));case 1:var r=n.b;return l(to,l(al,e,n.a),l(au,e,r));case 3:return n;case 2:return ac(l(au,e,r=n.a));default:var o=n.a;return te(l(n7,af(e),o))}}),as=r(function(e,n){return l(af,e,n)}),ad={src:"\n        precision lowp float;\n        \n        void main () {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    ",attributes:{},uniforms:{}},am=function(e){return function(n){return function(r){return function(o){return function(t){return function(a){return function(i){return function(c){return function(l){return function(u){return function(f){return{$:2,a:e,b:n,c:r,d:o,e:t,f:a,g:i,h:c,i:l,j:u,k:f}}}}}}}}}}}},av=o(function(e,n,r){return n(e(r))}),ap=o(function(e,n,o){var t=e.cJ,a=e.cn,i=e.cU,c=r(function(e,n){return n(e)}),f=r(function(e,n){return n(e)}),s=function(e){return l(av,c(e.bp),l(av,f(e.a8),l(av,f(e.by),f(e.bz))))};return l(s,o,l(s,n,u(am,t,a,i)))}),ag=u(ap,{cn:0,cJ:0,cU:15},{a8:7680,bp:519,by:7680,bz:7683},{a8:7680,bp:519,by:7680,bz:7682}),ab=u(ap,{cn:0,cJ:0,cU:15},{a8:7680,bp:519,by:7680,bz:7682},{a8:7680,bp:519,by:7680,bz:7683}),ah=r(function(e,n){return l(D,e?ab:ag,n)}),aC={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute highp vec3 normal;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 shadowLight;\n        \n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        vec3 getDirectionToLight(vec3 surfacePosition, vec4 xyz_type, vec4 rgb_parameter) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                return xyz_type.xyz;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                return normalize(lightPosition - surfacePosition);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 shadowVertexPosition(vec3 position, vec3 normal, mat4 shadowLight, vec4 modelScale, mat4 modelMatrix, mat4 viewMatrix, mat4 projectionMatrix, mat4 sceneProperties) {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            vec3 worldNormal = getWorldNormal(normal, vec4(modelScale.xyz, 1.0), modelMatrix);\n            vec4 xyz_type = shadowLight[0];\n            vec4 rgb_parameter = shadowLight[1];\n            vec3 directionToLight = getDirectionToLight(worldPosition.xyz, xyz_type, rgb_parameter);\n            vec3 offset = vec3(0.0, 0.0, 0.0);\n            float sceneDiameter = sceneProperties[3][1];\n            if (dot(directionToLight, worldNormal) <= 0.0) {\n                offset = -sceneDiameter * directionToLight;\n            } else {\n                offset = -0.001 * sceneDiameter * directionToLight;\n            }\n            vec4 offsetPosition = worldPosition + vec4(offset, 0.0);\n            return projectionMatrix * (viewMatrix * offsetPosition);\n        }\n        \n        void main () {\n            gl_Position = shadowVertexPosition(\n                position,\n                normal,\n                shadowLight,\n                modelScale,\n                modelMatrix,\n                viewMatrix,\n                projectionMatrix,\n                sceneProperties\n            );\n        }\n    ",attributes:{normal:"p",position:"bZ"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",shadowLight:"b3",viewMatrix:"f"}},ax=function(e){var n=function(e){if(e.$){var n=e.c;return nA(c(function(e,r,o,t,a,i,c,u){return s(e5,l(ah,t,u),aC,ad,n,{b:o,c:r,d:i,e:e,b3:c,f:a})}))}return nR}(e);return n.$?o9:ac(n.a)},aT=t(function(e,n,r,o){var t,a=l(t4,r,oB),i=(t=M(e,n)).a?t.b?tr(N([a,ax(o8)])):a:t.b?ax(o8):o9,c=o.en,u=c.a,f=c.b,s=c.c;return l(ai,o.ec,l(as,P(u,f,s),i))}),aM=r(function(e,n){return f(aT,!0,!1,e,n)}),aP=function(e){return e/180*$},ay=r(function(e,n){return{$:0,a:e,b:n}}),aL=function(e){var n=e.b;return l(ay,1664525*e.a+n>>>0,n)},aw=function(e){var n=e.a,r=0x108ef2d9*(n^n>>>4+(n>>>28));return(r>>>22^r)>>>0},aD=r(function(e,n){return function(r){var o=aL(r),t=oD(n-e),a=aw(o);return M((1*(0x3ffffff&aw(r))*0x8000000+1*(0x7ffffff&a))/0x20000000000000*t+e,aL(o))}}),aN=function(e){return{$:0,a:e}},aS=a(function(e,n,r,o,t){return{$:3,a:e,b:n,c:r,d:o,e:t}}),a_=o(function(e,n,r){return 0>x(r,e)?e:x(r,n)>0?n:r}),az=function(e){return u(a_,0,1,e>.04045?l(z,(e+.055)/1.055,2.4):e/12.92)},a$=t(function(e,n,r,o){return{$:0,a:e,b:n,c:r,d:o}}),aA=function(e){return e/255},aR=o(function(e,n,r){return f(a$,aA(e),aA(n),aA(r),1)}),aF=r(function(e,n){var r=e.cw,o=.5*n,t=A(o),a=R(o),i=e.eo,c=i.d6*a,l=t*c,u=c*c,f=i.d7*a,s=t*f,d=c*f,m=f*f,v=1-2*(u+m),p=i.b5*a,g=t*p,b=2*(d-g),h=2*(d+g),C=c*p,x=2*(C+s),T=2*(C-s),M=f*p,P=2*(M-l),y=2*(M+l),L=p*p,w=1-2*(m+L),D=1-2*(u+L);return{da:!0,r:w,s:h,t:T,u:b,v:D,w:y,x:x,y:P,z:v,I:r.d6-w*r.d6-b*r.d7-x*r.b5,J:r.d7-h*r.d6-D*r.d7-P*r.b5,K:r.b5-T*r.d6-y*r.d7-v*r.b5,b2:1}}),aB=o(function(e,n,r){return l(aa,l(aF,e,n),r)}),ak=o(function(e,n,r){return u(aB,e,n,r)}),aE=r(function(e,n){return e(n)}),aV=r(function(e,n){return{eo:n,cw:e}}),aj=function(e){return M(1,e)},aH=o(function(e,n,r){for(;;){var o=e.a,t=e.b;if(!n.b)return t;var a=n.a,i=n.b;if(1>x(r,oD(o)))return t;e=a,n=i,r-=oD(o)}}),aI=r(function(e,n){return function(r){var o=n(r),t=o.b;return M(e(o.a),t)}}),aW=r(function(e,n){var r=function(e){return oD(e.a)},o=r(e)+u(nB,_,0,l(n7,r,n));return l(aI,l(aH,e,n),l(aD,0,o))}),aO=r(function(e,n){return l(aW,aj(e),l(n7,aj,n))}),aU=function(e){return oD(e)},aY=r(function(e,n){return x(n,e)>-1}),aq=r(function(e,n){return e+.5*(n-e)}),aG={d6:-1,d7:0,b5:0},aZ={d6:0,d7:-1,b5:0},aX={d6:0,d7:0,b5:-1},aK={d6:1,d7:0,b5:0},aJ={d6:0,d7:1,b5:0},aQ={d6:0,d7:0,b5:1},a0=i(function(e,n,r,o,t,a){var i=l(aY,r,a)?aQ:aX,c=l(aY,n,t)?aJ:aZ,f=l(aY,e,o)?aK:aG,s=P(aU(l(t3,e,o)),aU(l(t3,n,t)),aU(l(t3,r,a)));return{ec:{cw:u(oF,l(aq,e,o),l(aq,n,t),l(aq,r,a)),cV:f,cW:c,cX:i},en:s}}),a3=t(function(e,n,r,o){var t,a,i,c,f,m,v,p,g,b,h,C=l(aM,(i=(a={ee:(t={ee:u(aR,91,192,235),eX:.6}).ee,cr:0,eX:t.eX}).eX,c=a.cr,s(aS,0,aN((v=(m={aL:(f=a.ee).d,b9:f.c,cd:f.b,cI:f.a}).cd,p=m.b9,u(eJ,az(m.cI),az(v),az(p)))),aN(u(a_,0,1,i)),aN(u(a_,0,1,c)),aN(0))),d(a0,(g={fc:e+r,fd:e+r+.6,ff:e+o,fg:e+o+.6,fi:0,fj:.6}).fc,g.ff,g.fi,g.fd,g.fg,g.fj)),x=function(e){return aP(e+n/500)},T=l(aE,l(or,function(e){var n,r,o;return l(aO,{d6:A(n=x(e)),d7:R(n),b5:0},N([{d6:0,d7:A(r=x(e)),b5:R(r)},{d6:0,d7:R(o=x(e)),b5:A(o)}]))},l(aD,0,1e4)),(b=r+1e3*o,h=aL(l(ay,0,0x3c6ef35f)),aL(l(ay,h.a+b>>>0,h.b)))).a;return u(ak,l(aV,u(oF,r+.3+e,o+.3+e,.3),T),aP(n/150+r/3+o/3),C)}),a1=r(function(e,n){return o7(l(n7,e,n))}),a2=ew("div"),a4=function(e){return l(eS,"height",e+"")},a5=function(e){var n=l(nZ,oD(e.d6),l(nZ,oD(e.d7),oD(e.b5)));if(n){var r=e.b5/n,o=e.d7/n,t=e.d6/n,a=V(t*t+o*o+r*r);return nA({d6:t/a,d7:o/a,b5:r/a})}return nR},a6=r(function(e,n){return n.$?nR:e(n.a)}),a7=r(function(e,n){return n.d6*e.d6+n.d7*e.d7+n.b5*e.b5}),a8=r(function(e,n){return x(n,e)>0}),a9=r(function(e,n){return 0>x(n,e)}),ie=r(function(e,n){return n.$?nR:nA(e(n.a))}),ir=r(function(e,n){return{d6:n.d6-e.d6,d7:n.d7-e.d7,b5:n.b5-e.b5}}),io=r(function(e,n){var r=n.d6*e.d6+n.d7*e.d7+n.b5*e.b5;return{d6:e.d6*r,d7:e.d7*r,b5:e.b5*r}}),it=o(function(e,n,r){return l(a6,function(o){return l(a6,function(t){var a=l(oL,n,e),i=l(a7,r,a),c=l(a8,0,i)?a:l(a9,0,i)?{d6:-a.d6,d7:-a.d7,b5:-a.b5}:oN;return l(ie,function(e){return P(o,t,e)},a5(c))},a5(l(ir,l(io,o,n),n)))},a5(e))}),ia=function(e){var n=function(e){var n=oD(e.b5),r=oD(e.d7),o=oD(e.d6);if(1>x(o,r)){if(1>x(o,n)){var t=V(e.b5*e.b5+e.d7*e.d7);return{d6:0,d7:-e.b5/t,b5:e.d7/t}}return t=V(e.d7*e.d7+e.d6*e.d6),{d6:-e.d7/t,d7:e.d6/t,b5:0}}return 1>x(r,n)?(t=V(e.b5*e.b5+e.d6*e.d6),{d6:e.b5/t,d7:0,b5:-e.d6/t}):(t=V(e.d6*e.d6+e.d7*e.d7),{d6:-e.d7/t,d7:e.d6/t,b5:0})}(e);return M(n,{d6:e.d7*n.b5-e.b5*n.d7,d7:e.b5*n.d6-e.d6*n.b5,b5:e.d6*n.d7-e.d7*n.d6})},ii=r(function(e,n){var r=ia(e);return{cw:n,cV:r.a,cW:r.b,cX:e}}),ic=function(e){var n=l(ow,e.eA,e.ex),r=e.d4,o=u(it,n,r,l(oL,n,r));if(o.$){var t=a5(n);if(t.$){var a=ia(e.d4);return{cw:e.ex,cV:a.b,cW:e.d4,cX:a.a}}return l(ii,t.a,e.ex)}var i=o.a;return{cw:e.ex,cV:i.c,cW:i.b,cX:i.a}},il=o(function(e,n,r){return{d6:e,d7:n,b5:r}}),iu=function(e){return .5*e},is={$:3},id=t(function(e,n,r,o){return{$:4,a:e,b:n,c:r,d:o}}),im=function(e){return eD("script"==e?"p":e)},iv=o(function(e,n,r){return u(ns,e,n,r)}),ip=f(e0,1,1,1,1),ig=o(function(e,n,r){return l(n7,function(e){return l(e,n,r)},e)}),ib=o(function(e,n,r){return{$:0,a:e,b:n,c:r}}),ih=r(function(e,n){var r=n.d6,o=n.d7;return u(ib,e*r/o,e,e*(1-r-o)/o)}),iC=r(function(e,n){var r,o,t,a;return u(eJ,3.2406*(o=(r=l(ih,e,n)).a)-1.5372*(t=r.b)-.4986*(a=r.c),-.9689*o+1.8758*t+.0415*a,.0557*o-.204*t+1.057*a)}),ix=function(e){var n=new Float64Array(16);return n[0]=e.dj,n[1]=e.dn,n[2]=e.dr,n[3]=e.dv,n[4]=e.dk,n[5]=e.$7,n[6]=e.ds,n[7]=e.dw,n[8]=e.dl,n[9]=e.dp,n[10]=e.dt,n[11]=e.dx,n[12]=e.dm,n[13]=e.dq,n[14]=e.du,n[15]=e.dy,n},iT=a(function(e,n,r,o,t){return d(t,e,f(e0,o.b2,o.b2,o.b2,o.da?1:-1),ix({dj:o.r,dk:o.u,dl:o.x,dm:o.I,dn:o.s,$7:o.v,dp:o.y,dq:o.J,dr:o.t,ds:o.w,dt:o.z,du:o.K,dv:0,dw:0,dx:0,dy:1}),o.da,n,r)}),iM=i(function(e,n,r,o,t,a){for(;;)switch(t.$){case 0:return a;case 5:var i=t.b;o=l(at,t.a,o),t=i;continue;case 1:return{O:l(D,s(iT,e,n,r,o,t.b),a.O),Z:a.Z,eY:a.eY};case 3:return{O:a.O,Z:l(D,s(iT,e,n,r,o,t.b),a.Z),eY:a.eY};case 2:return{O:a.O,Z:a.Z,eY:l(D,s(iT,e,n,r,o,t.a),a.eY)};default:var c=t.a;return u(nB,f(iM,e,n,r,o),a,c)}}),iP=t(function(e,n,r,o){return{$:4,a:e,b:n,c:r,d:o}}),iy=t(function(e,n,r,o){return{$:1,a:e,b:n,c:r,d:o}}),iL=r(function(e,n){return{$:6,a:e,b:n}}),iw=N([f(iy,518,!1,0,1),f(iP,!1,!1,!1,!1),l(iL,0,1)]),iD={src:"\n        precision lowp float;\n\n        void main() {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n    ",attributes:{},uniforms:{}},iN=r(function(e,n){return{$:0,a:e,b:n}})({c1:1,c9:0,dH:5})(N([{bZ:l(eK,-1,-1)},{bZ:l(eK,1,-1)},{bZ:l(eK,-1,1)},{bZ:l(eK,1,1)}])),iS={src:"\n        precision lowp float;\n\n        attribute vec2 position;\n\n        void main() {\n            gl_Position = vec4(position, 0.0, 1.0);\n        }\n    ",attributes:{position:"bZ"},uniforms:{}},i_=function(e){return u(ap,{cn:e.cn,cJ:e.cJ,cU:e.cU},{a8:e.a8,bp:e.bp,by:e.by,bz:e.bz},{a8:e.a8,bp:e.bp,by:e.by,bz:e.bz})},iz=function(e){return s(e5,N([i_(e),f(iP,!1,!1,!1,!1)]),iS,iD,iN,{})},i$=iz({a8:7681,cn:0,cJ:8,bp:519,cU:15,by:7681,bz:7681}),iA=function(e){return iz({a8:7680,cn:15,cJ:8,bp:516,cU:l(z,2,e+4),by:5386,bz:5386})},iR=o(function(e,n,r){return o7(N([u(ig,e,r,iw),N([iA(n),i$])]))}),iF=r(function(e,n){return o7(l(nj,iR(e),n))}),iB=f(iy,513,!0,0,1),ik=o(function(e,n,r){return{$:0,a:e,b:n,c:r}}),iE=r(function(e,n){return u(ik,32774,e,n)}),iV=(rH=(rj={bA:0,aL:l(iE,1,771),bD:0,bG:l(iE,770,771),bK:0,b$:0}).b$,rI=rj.bK,rW=rj.bD,rO=rj.bA,rU=rj.bG,rY=rj.aL,l(r(function(e,n){var r,o=e.b,t=e.c,a=n.a,i=n.b,c=n.c;return(r=e.a,function(e){return function(n){return function(o){return function(t){return function(a){return function(i){return function(c){return function(l){return function(u){return{$:0,a:r,b:e,c:n,d:o,e:t,f:a,g:i,h:c,i:l,j:u}}}}}}}}}})(o)(t)(a)(i)(c)(rH)(rI)(rW)(rO)}),rU,rY)),ij=N([iB,iV]),iH=function(e){return t9(e)},iI=r(function(e,n){var r=e.cX,o=e.cW,t=e.cV;return{d6:n.d6*t.d6+n.d7*t.d7+n.b5*t.b5,d7:n.d6*o.d6+n.d7*o.d7+n.b5*o.b5,b5:n.d6*r.d6+n.d7*r.d7+n.b5*r.b5}}),iW=r(function(e,n){var r=e.cw,o=n.d6-r.d6,t=n.d7-r.d7,a=n.b5-r.b5,i=e.cX,c=e.cW,l=e.cV;return{d6:o*l.d6+t*l.d7+a*l.b5,d7:o*c.d6+t*c.d7+a*c.b5,b5:o*i.d6+t*i.d7+a*i.b5}}),iO=r(function(e,n){return{cw:l(iW,e,t9(n)),cV:l(iI,e,ae(n)),cW:l(iI,e,an(n)),cX:l(iI,e,ar(n))}}),iU=r(function(e,n){return{dA:l(os,e.dA,n.dA),dB:l(os,e.dB,n.dB),dC:l(os,e.dC,n.dC),dD:l(om,e.dD,n.dD),dE:l(om,e.dE,n.dE),dF:l(om,e.dF,n.dF)}}),iY=r(function(e,n){return n+e}),iq=r(function(e,n){var r=e.a,o=e.c,t=iu(aU(e.b)),a=iu(aU(r)),i=iu(aU(o)),c=P(n.d6,n.d7,n.b5),u=c.a,f=c.b,s=c.c;return{dA:l(iY,a,u),dB:l(iY,t,f),dC:l(iY,i,s),dD:l(t3,a,u),dE:l(t3,t,f),dF:l(t3,i,s)}}),iG=t(function(e,n,r,o){var t=r.ei,a=2*r.eD*n,i=2*r.eC*n,c=2*r.eB*n,f=t.b5*n,s=t.d7*n,d=t.d6*n,m=ar(e),v=oD(c*m.d6)+oD(i*m.d7)+oD(a*m.b5),p=an(e),g=oD(c*p.d6)+oD(i*p.d7)+oD(a*p.b5),b=ae(e),h=l(iq,P(oD(c*b.d6)+oD(i*b.d7)+oD(a*b.b5),g,v),l(iW,e,u(il,d,s,f)));return nA(o.$?h:l(iU,o.a,h))}),iZ=t(function(e,n,r,o){for(;;){if(!o.b)return r;var t=o.a,a=o.b;switch(t.$){case 0:case 2:e=c=e,n=u=n,r=s=r,o=a;continue;case 1:var i=f(iG,e,n,t.a,r);e=c=e,n=u=n,r=s=i,o=a;continue;case 3:i=f(iG,e,n,t.a,r),e=c=e,n=u=n,r=s=i,o=a;continue;case 4:c=e,u=n,s=f(iZ,e,n,r,t.a),e=c,n=u,r=s,o=a;continue;default:var c,u,s,d=t.a,m=t.b,v=l(iO,{cw:{d6:d.I,d7:d.J,b5:d.K},cV:{d6:d.r,d7:d.s,b5:d.t},cW:{d6:d.u,d7:d.v,b5:d.w},cX:{d6:d.x,d7:d.y,b5:d.z}},e),p=n*d.b2;e=c=e,n=u=n,r=s=f(iZ,v,p,r,N([m])),o=a;continue}}}),iX={da:!0,r:1,s:0,t:0,u:0,v:1,w:0,x:0,y:0,z:1,I:0,J:0,K:0,b2:1},iK=iz({a8:7681,cn:0,cJ:8,bp:519,cU:255,by:7681,bz:7681}),iJ={bD:0,eh:!1,bK:0,cF:0,b$:0,cR:0,d6:0,d7:0,b5:0},iQ=r(function(e,n){return ix({dj:e.d6,dk:e.b$,dl:n.d6,dm:n.b$,dn:e.d7,$7:e.bK,dp:n.d7,dq:n.bK,dr:e.b5,ds:e.bD,dt:n.b5,du:n.bD,dv:e.cR,dw:e.cF,dx:n.cR,dy:n.cF})}),i0=M({bd:l(iQ,iJ,iJ),bP:l(iQ,iJ,iJ),bQ:l(iQ,iJ,iJ),bR:l(iQ,iJ,iJ)},f(e0,0,0,0,0)),i3=function(e){return-e},i1=function(e){return f(iy,515,e.ad,e.aa,e._)},i2=N([i1({_:1,aa:0,ad:!0}),i_({a8:7680,cn:240,cJ:0,bp:514,cU:0,by:7680,bz:7680}),iV]),i4=function(e){return e===1/0||e===-1/0},i5=r(function(e,n){var r=n.ez,o=n.eb,t=aU(n.eP),a=aU(r),i=e.cH;if(i.$){var c=i.a;return i4(a)?ix({dj:2/(o*c),dk:0,dl:0,dm:0,dn:0,$7:2/c,dp:0,dq:0,dr:0,ds:0,dt:0,du:-1,dv:0,dw:0,dx:0,dy:1}):ix({dj:2/(o*c),dk:0,dl:0,dm:0,dn:0,$7:2/c,dp:0,dq:0,dr:0,ds:0,dt:-2/(a-t),du:-(a+t)/(a-t),dv:0,dw:0,dx:0,dy:1})}var l=i.a;return i4(a)?ix({dj:1/(o*l),dk:0,dl:0,dm:0,dn:0,$7:1/l,dp:0,dq:0,dr:0,ds:0,dt:-1,du:-2*t,dv:0,dw:0,dx:-1,dy:0}):ix({dj:1/(o*l),dk:0,dl:0,dm:0,dn:0,$7:1/l,dp:0,dq:0,dr:0,ds:0,dt:-(a+t)/(a-t),du:-2*a*t/(a-t),dv:0,dw:0,dx:-1,dy:0})}),i6=r(function(e,n){return 1==(1&e>>n)?0:1}),i7=o(function(e,n,r){return o7(l(n7,function(r){var o=r<<4;return u(ig,e,M(n,f(e0,l(i6,r,0),l(i6,r,1),l(i6,r,2),l(i6,r,3))),N([i1({_:1,aa:0,ad:!0}),i_({a8:7680,cn:240,cJ:o,bp:514,cU:0,by:7680,bz:7680}),iV]))},l(nV,1,l(z,2,r)-1)))}),i8=function(e){return{d6:-e.d6,d7:-e.d7,b5:-e.b5}},i9=function(e){return i8(ar(e))},ce={cw:{d6:0,d7:0,b5:0},cV:aK,cW:aJ,cX:aQ},cn=r(function(e,n){var r,o,t,a,i;return o=t9(r=l(iO,n,e)),t=ar(r),a=an(r),ix({dj:(i=ae(r)).d6,dk:a.d6,dl:t.d6,dm:o.d6,dn:i.d7,$7:a.d7,dp:t.d7,dq:o.d7,dr:i.b5,ds:a.b5,dt:t.b5,du:o.b5,dv:0,dw:0,dx:0,dy:1})}),cr=o(function(e,n,r){return{d6:e,d7:n,b5:r}}),co=function(e){return l(eS,"width",e+"")},ct=r(function(e,n){var r,o,t,a,i,c=N([{$:1,a:1},{$:2,a:0},{$:0,a:!0},f(id,0,0,0,0)]),s=function(){var n=e.aM;switch(n.$){case 0:return P(c,"0",1);case 1:return P(l(D,is,c),"1",1);default:return P(c,"0",n.a)}}(),m=s.a,v=s.b,p=s.c,g=e.en,b=g.a,h=g.b,C=l(eN,"height",h+"px"),x=b/h,T=l(a1,function(n){return function(e){var n=e.eg.e7,r={cw:iH(n),cV:ae(n),cW:an(n),cX:i8(i9(n))},o=tr(e.et),t=f(iZ,r,1,nR,N([o]));if(1===t.$)return L;var a=t.a,i=l(cn,ce,n),c=l(oR,.99,l(os,aU(e.ek),i3(tQ(a)))),s=t1(a),m=function(e){var n=l(nZ,oD(e.d6),l(nZ,oD(e.d7),oD(e.b5)));if(n){var r=e.b5/n,o=e.d7/n,t=e.d6/n;return V(t*t+o*o+r*r)*n}return 0}(u(cr,s.a,s.b,s.c)),v=l(oR,1.01,l(iY,m,i3(t0(a)))),p=l(i5,e.eg,{eb:e.eb,ez:v,eP:c}),g={dj:p[0],dn:p[1],dr:p[2],dv:p[3],dk:p[4],$7:p[5],ds:p[6],dw:p[7],dl:p[8],dp:p[9],dt:p[10],dx:p[11],dm:p[12],dq:p[13],du:p[14],dy:p[15]}.dy,b=g?i8(i9(n)):iH(n),h=function(){var n=e.aw;switch(n.$){case 0:return M(0,0);case 1:return M(1,0);case 2:return M(2,0);case 3:return M(3,n.a);case 4:return M(4,n.a);default:return M(5,0)}}(),C=h.a,x=h.b,T=l(iC,e.ap,e.az),P=d(iM,ix({dj:0,dk:b.d6,dl:tF(T),dm:e.d$,dn:0,$7:b.d7,dp:tB(T),dq:m,dr:0,ds:b.b5,dt:tk(T),du:C,dv:0,dw:g,dx:0,dy:x}),i,p,iX,o,{O:L,Z:L,eY:L}),y=e.ar;switch(y.$){case 0:return o7(N([u(ig,P.O,M(w=y.a,ip),ij),u(ig,P.Z,i0,ij)]));case 1:var w=y.a;return o7(N([u(ig,P.O,i0,ij),N([iK]),u(ig,P.eY,w.bd,iw),N([iA(0)]),u(ig,P.O,M(w,ip),i2),u(ig,P.Z,i0,ij)]));default:var D=y.a,S=y.b;return o7(N([u(ig,P.O,M(S,ip),ij),N([iK]),l(iF,P.eY,D),u(i7,P.O,S,nk(D)),u(ig,P.Z,i0,ij)]))}}({eb:x,eg:e.eg,ek:e.ek,et:n.et,ap:n.ap,ar:n.ar,d$:p,aw:n.aw,az:n.az})},n),y=l(eN,"width",b+"px"),w=(o=(r=e.ed).b,t=r.c,a=r.d,l(nF,"",N(["rgba(",(i=function(e){return E(1e4*e)/100})(r.a)+"","%,",i(o)+"","%,",i(t)+"","%,",E(1e3*a)/1e3+"",")"])));return u(im,"div",N([l(eN,"padding","0px"),y,C]),N([M(v,u(iv,m,N([co(E(b*p)),a4(E(h*p)),y,C,l(eN,"display","block"),l(eN,"background-color",w)]),T))]))}),ca={d6:.31271,d7:.32902},ci=r(function(e,n){var r=n.eo,o=r.d6,t=r.d7,a=r.b5,i=l(iC,n.ce,n.bF);return{bD:tk(i),eh:e,bK:tB(i),cF:0,b$:tF(i),cR:1,d6:-o,d7:-t,b5:-a}}),cc={$:1},cl={$:0},cu=function(e){return function(e){for(;;){if(h(e.eJ,0)&&h(e.eK,0))return iJ;if(!l(a8,aU(e.eJ),aU(e.eK))){var n=oD(e.eK/$),r=oD(e.eJ/$),o=e.d4,t=o.d6,a=o.d7,i=o.b5,c=l(iC,1,e.bF);return{bD:r*tk(c),eh:!1,bK:r*tB(c),cF:n/r,b$:r*tF(c),cR:3,d6:t,d7:a,b5:i}}e={bF:e.bF,eJ:e.eK,eK:e.eJ,d4:i8(e.d4)}}}({bF:e.bF,eJ:e.ce,eK:0,d4:e.d4})},cf=function(e){var n=u(a_,1667,25e3,e),r=n>4e3?-0xb45ac274/(n*n*n)+2107037.9/(n*n)+.2226347*1e3/n+.24039:-266123900.00000003/(n*n*n)-.2343589*1e6/(n*n)+877.6956/n+.17991;return{d6:r,d7:n>2222?n>4e3?r*r*r*3.081758-r*r*5.8733867+3.75112997*r-.37001483:-(r*r*r*.9549476)-r*r*1.37418593+2.09137015*r-.16748867:-(r*r*r*1.1063814)-r*r*1.3481102+2.18555832*r-.20219683}},cs=cf(12e3),cd=cf(5600),cm=r(function(e,n){return{$:2,a:e,b:n}}),cv=function(e){return{$:0,a:e}},cp=function(e){return e.eh},cg=cv(i0.a),cb=r(function(e,n){return u(n6,r(function(n,r){var o=r.a,t=r.b;return e(n)?M(l(D,n,o),t):M(o,l(D,n,t))}),M(L,L),n)}),ch=function(e){return ix({dj:e.d6,dk:e.b$,dl:0,dm:0,dn:e.d7,$7:e.bK,dp:0,dq:0,dr:e.b5,ds:e.bD,dt:0,du:0,dv:e.cR,dw:e.cF,dx:0,dy:0})},cC=c(function(e,n,r,o,t,a,i,c){var u=l(cb,cp,N([e,n,r,o])),f=u.a;if(f.b){var s=y(f,u.b);if(s.b&&s.b.b&&s.b.b.b&&s.b.b.b.b&&!s.b.b.b.b.b){var d=s.a,m=s.b,v=m.a,p=m.b,g=p.a,b=p.b.a;return l(cm,l(n7,ch,f),{bd:l(iQ,d,v),bP:l(iQ,g,b),bQ:l(iQ,t,a),bR:l(iQ,i,c)})}return cg}return cv({bd:l(iQ,e,n),bP:l(iQ,r,o),bQ:l(iQ,t,a),bR:l(iQ,i,c)})}),cx=o(function(e,n,r){return m(cC,e,n,r,iJ,iJ,iJ,iJ,iJ)}),cT=function(e){var n,r=u(cx,l(ci,e.eY,{bF:cd,eo:e.e1,ce:8e4}),cu({bF:cs,ce:2e4,d4:e.d4}),cu({bF:ca,ce:15e3,d4:i8(e.d4)}));return n={aM:cc,ed:e.ed,eg:e.eg,ek:e.ek,en:e.en,et:e.et,ap:1.2*l(z,2,15),ar:r,aw:cl,az:ca},l(ct,{aM:n.aM,ed:n.ed,eg:n.eg,ek:n.ek,en:n.en},N([{et:n.et,ap:n.ap,ar:n.ar,aw:n.aw,az:n.az}]))},cM=f(t(function(e,n,r,o){return f(a$,e,n,r,o)}),0,0,0,0);r7={Main:{init:eW({eI:function(){return rl},e0:function(){return{$:2,m:N([u(r9,1,"resize",l(O,"target",u(q,nL,l(O,"innerWidth",W),l(O,"innerHeight",W)))),rh(ru(nw))])}},e3:on,e6:function(e){var n;return l(a2,N([co(e.bk),a4(e.bl),l(eN,"background-color","rgb(33, 26, 64)")]),N([cT({ed:cM,eg:{cH:{$:0,a:F(iu(aU((n={e5:aP(35),e7:ic({ex:u(il,0,0,85),eA:u(il,0,0,0),d4:aQ})}).e5)))},e7:n.e7},ek:.1,en:M(e.bk,e.bl),et:l(a1,function(n){return l(n7,function(r){return f(a3,-25.5,e.bs,n,r)},l(nV,1,50))},l(nV,1,50)),eY:!1,e1:aX,d4:aQ})]))}})({$:0,a:0})(0)}},e.Elm?function e(n,r){for(var o in r)o in n?"init"==o?b(6):e(n[o],r[o]):n[o]=r[o]}(e.Elm,r7):e.Elm=r7}(e),(0,e.Elm).Main.init({node:document.getElementById("root")});
//# sourceMappingURL=index.1db48d1c.js.map
