(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[,function(){!function(e){"use strict";function n(e,n,r){return r.a=e,r.f=n,r}function r(e){return n(2,e,function(n){return function(r){return e(n,r)}})}function t(e){return n(3,e,function(n){return function(r){return function(t){return e(n,r,t)}}})}function o(e){return n(4,e,function(n){return function(r){return function(t){return function(o){return e(n,r,t,o)}}}})}function a(e){return n(5,e,function(n){return function(r){return function(t){return function(o){return function(a){return e(n,r,t,o,a)}}}}})}function i(e){return n(6,e,function(n){return function(r){return function(t){return function(o){return function(a){return function(i){return e(n,r,t,o,a,i)}}}}}})}function c(e){return n(8,e,function(n){return function(r){return function(t){return function(o){return function(a){return function(i){return function(c){return function(l){return e(n,r,t,o,a,i,c,l)}}}}}}}})}function l(e,n,r){return 2===e.a?e.f(n,r):e(n)(r)}function u(e,n,r,t){return 3===e.a?e.f(n,r,t):e(n)(r)(t)}function f(e,n,r,t,o){return 4===e.a?e.f(n,r,t,o):e(n)(r)(t)(o)}function s(e,n,r,t,o,a){return 5===e.a?e.f(n,r,t,o,a):e(n)(r)(t)(o)(a)}function d(e,n,r,t,o,a,i){return 6===e.a?e.f(n,r,t,o,a,i):e(n)(r)(t)(o)(a)(i)}function m(e,n,r,t,o,a,i,c,l){return 8===e.a?e.f(n,r,t,o,a,i,c,l):e(n)(r)(t)(o)(a)(i)(c)(l)}var v=t(function(e,n,r){for(var t=Array(e),o=0;o<e;o++)t[o]=r(n+o);return t}),p=r(function(e,n){for(var r=Array(e),t=0;t<e&&n.b;t++)r[t]=n.a,n=n.b;return r.length=t,M(r,n)}),g=r(function(e,n){return n[e]});function b(e){throw Error("https://github.com/elm/core/blob/1.0.0/hints/"+e+".md")}function h(e,n){for(var r,t=[],o=C(e,n,0,t);o&&(r=t.pop());o=C(r.a,r.b,0,t));return o}function C(e,n,r,t){if(e===n)return!0;if("object"!==typeof e||null===e||null===n)return"function"===typeof e&&b(5),!1;if(r>100)return t.push(M(e,n)),!0;for(var o in e.$<0&&(e=Jn(e),n=Jn(n)),e)if(!C(e[o],n[o],r+1,t))return!1;return!0}function x(e,n,r){if("object"!==typeof e)return e===n?0:e<n?-1:1;if("undefined"===typeof e.$)return(r=x(e.a,n.a))?r:(r=x(e.b,n.b))?r:x(e.c,n.c);for(;e.b&&n.b&&!(r=x(e.a,n.a));e=e.b,n=n.b);return r||(e.b?1:n.b?-1:0)}var T=r(function(e,n){var r=x(e,n);return r<0?nr:r?er:Qn});function M(e,n){return{a:e,b:n}}function P(e,n,r){return{a:e,b:n,c:r}}function y(e,n){var r={};for(var t in e)r[t]=e[t];for(var t in n)r[t]=n[t];return r}function L(e,n){if("string"===typeof e)return e+n;if(!e.b)return n;var r=D(e.a,n);e=e.b;for(var t=r;e.b;e=e.b)t=t.b=D(e.a,n);return r}var w={$:0};function D(e,n){return{$:1,a:e,b:n}}var N=r(D);function S(e){for(var n=w,r=e.length;r--;)n=D(e[r],n);return n}var _=t(function(e,n,r){for(var t=[];n.b&&r.b;n=n.b,r=r.b)t.push(l(e,n.a,r.a));return S(t)}),z=r(function(e,n){return e+n}),$=r(Math.pow),A=Math.cos,R=Math.sin,F=Math.tan,B=Math.ceil,k=Math.floor,E=Math.round,V=Math.sqrt,j=Math.log,H=r(function(e,n){return n.join(e)});function I(e){return e+""}function W(e){return{$:2,b:e}}var O=W(function(e){return"number"!==typeof e?ee("an INT",e):-2147483647<e&&e<2147483647&&(0|e)===e?lr(e):!isFinite(e)||e%1?ee("an INT",e):lr(e)});W(function(e){return"boolean"===typeof e?lr(e):ee("a BOOL",e)}),W(function(e){return"number"===typeof e?lr(e):ee("a FLOAT",e)}),W(function(e){return lr(te(e))}),W(function(e){return"string"===typeof e?lr(e):e instanceof String?lr(e+""):ee("a STRING",e)});var U=r(function(e,n){return{$:6,d:e,b:n}});function Y(e,n){return{$:9,f:e,g:n}}var q=r(function(e,n){return Y(e,[n])}),G=t(function(e,n,r){return Y(e,[n,r])}),Z=r(function(e,n){return X(e,oe(n))});function X(e,n){switch(e.$){case 2:return e.b(n);case 5:return null===n?lr(e.c):ee("null",n);case 3:return J(n)?K(e.b,n,S):ee("a LIST",n);case 4:return J(n)?K(e.b,n,Q):ee("an ARRAY",n);case 6:var r=e.d;if("object"!==typeof n||null===n||!(r in n))return ee("an OBJECT with a field named `"+r+"`",n);var t=X(e.b,n[r]);return Vr(t)?t:or(l(ir,r,t.a));case 7:var o=e.e;return J(n)?o<n.length?(t=X(e.b,n[o]),Vr(t)?t:or(l(cr,o,t.a))):ee("a LONGER array. Need index "+o+" but only see "+n.length+" entries",n):ee("an ARRAY",n);case 8:if("object"!==typeof n||null===n||J(n))return ee("an OBJECT",n);var a=w;for(var i in n)if(n.hasOwnProperty(i)){if(t=X(e.b,n[i]),!Vr(t))return or(l(ir,i,t.a));a=D(M(i,t.a),a)}return lr(Tr(a));case 9:for(var c=e.f,u=e.g,f=0;f<u.length;f++){if(t=X(u[f],n),!Vr(t))return t;c=c(t.a)}return lr(c);case 10:return t=X(e.b,n),Vr(t)?X(e.h(t.a),n):t;case 11:for(var s=w,d=e.g;d.b;d=d.b){if(t=X(d.a,n),Vr(t))return t;s=D(t.a,s)}return or(ur(Tr(s)));case 1:return or(l(ar,e.a,te(n)));case 0:return lr(e.a)}}function K(e,n,r){for(var t=n.length,o=Array(t),a=0;a<t;a++){var i=X(e,n[a]);if(!Vr(i))return or(l(cr,a,i.a));o[a]=i.a}return lr(r(o))}function J(e){return Array.isArray(e)||"undefined"!==typeof FileList&&e instanceof FileList}function Q(e){return l(Er,e.length,function(n){return e[n]})}function ee(e,n){return or(l(ar,"Expecting "+e,te(n)))}function ne(e,n){if(e===n)return!0;if(e.$!==n.$)return!1;switch(e.$){case 0:case 1:return e.a===n.a;case 2:return e.b===n.b;case 5:return e.c===n.c;case 3:case 4:case 8:return ne(e.b,n.b);case 6:return e.d===n.d&&ne(e.b,n.b);case 7:return e.e===n.e&&ne(e.b,n.b);case 9:return e.f===n.f&&re(e.g,n.g);case 10:return e.h===n.h&&ne(e.b,n.b);case 11:return re(e.g,n.g)}}function re(e,n){var r=e.length;if(r!==n.length)return!1;for(var t=0;t<r;t++)if(!ne(e[t],n[t]))return!1;return!0}function te(e){return e}function oe(e){return e}function ae(e){return{$:0,a:e}}function ie(e){return{$:2,b:e,c:null}}te(null);var ce=r(function(e,n){return{$:3,b:e,d:n}}),le=0;function ue(e){var n={$:0,e:le++,f:e,g:null,h:[]};return pe(n),n}function fe(e){return ie(function(n){n(ae(ue(e)))})}function se(e,n){e.h.push(n),pe(e)}var de=r(function(e,n){return ie(function(r){se(e,n),r(ae(0))})}),me=!1,ve=[];function pe(e){if(ve.push(e),!me){for(me=!0;e=ve.shift();)ge(e);me=!1}}function ge(e){for(;e.f;){var n=e.f.$;if(0===n||1===n){for(;e.g&&e.g.$!==n;)e.g=e.g.i;if(!e.g)return;e.f=e.g.b(e.f.a),e.g=e.g.i}else{if(2===n)return void(e.f.c=e.f.b(function(n){e.f=n,pe(e)}));if(5===n){if(0===e.h.length)return;e.f=e.f.b(e.h.shift())}else e.g={$:3===n?0:1,b:e.f.b,i:e.g},e.f=e.f.d}}}var be={};function he(e,n,r,t,o){return{b:e,c:n,d:r,e:t,f:o}}function Ce(e,n){var r={g:n,h:void 0},t=e.c,o=e.d,a=e.e,i=e.f;return r.h=ue(l(ce,function e(n){return l(ce,e,{$:5,b:function(e){var c=e.a;return 0===e.$?u(o,r,c,n):a&&i?f(t,r,c.i,c.j,n):u(t,r,a?c.i:c.j,n)}})},e.b))}var xe=r(function(e,n){return ie(function(r){e.g(n),r(ae(0))})}),Te=r(function(e,n){return l(de,e.h,{$:0,a:n})});function Me(e){return function(n){return{$:1,k:e,l:n}}}function Pe(e){return{$:2,m:e}}var ye,Le=[],we=!1;function De(e,n,r){if(Le.push({p:e,q:n,r:r}),!we){we=!0;for(var t;t=Le.shift();)Ne(t.p,t.q,t.r);we=!1}}function Ne(e,n,r){var t={};for(var o in Se(!0,n,t,null),Se(!1,r,t,null),e)se(e[o],{$:"fx",a:t[o]||{i:w,j:w}})}function Se(e,n,r,t){switch(n.$){case 1:var o=n.k,a=function(e,r,t){return l(e?be[r].e:be[r].f,function(e){for(var n=t;n;n=n.t)e=n.s(e);return e},n.l)}(e,o,t);return void(r[o]=function(e,n,r){return r=r||{i:w,j:w},e?r.i=D(n,r.i):r.j=D(n,r.j),r}(e,a,r[o]));case 2:for(var i=n.m;i.b;i=i.b)Se(e,i.a,r,t);return;case 3:return void Se(e,n.o,r,{s:n.n,t:t})}}var _e="undefined"!==typeof document?document:{};function ze(e,n){e.appendChild(n)}function $e(e){return{$:0,a:e}}var Ae,Re=r(function(e,n){return r(function(r,t){for(var o=[],a=0;t.b;t=t.b){var i=t.a;a+=i.b||0,o.push(i)}return a+=o.length,{$:1,c:n,d:Ee(r),e:o,f:e,b:a}})})(void 0),Fe=r(function(e,n){return r(function(r,t){for(var o=[],a=0;t.b;t=t.b){var i=t.a;a+=i.b.b||0,o.push(i)}return a+=o.length,{$:2,c:n,d:Ee(r),e:o,f:e,b:a}})})(void 0),Be=r(function(e,n){return{$:"a1",n:e,o:n}}),ke=r(function(e,n){return{$:"a3",n:e,o:n}});function Ee(e){for(var n={};e.b;e=e.b){var r=e.a,t=r.$,o=r.n,a=r.o;if("a2"!==t){var i=n[t]||(n[t]={});"a3"===t&&"class"===o?Ve(i,o,a):i[o]=a}else"className"===o?Ve(n,o,oe(a)):n[o]=oe(a)}return n}function Ve(e,n,r){var t=e[n];e[n]=t?t+" "+r:r}function je(e,n){var r=e.$;if(5===r)return je(e.k||(e.k=e.m()),n);if(0===r)return _e.createTextNode(e.a);if(4===r){for(var t=e.k,o=e.j;4===t.$;)"object"!==typeof o?o=[o,t.j]:o.push(t.j),t=t.k;var a={j:o,p:n};return(i=je(t,a)).elm_event_node_ref=a,i}if(3===r)return He(i=e.h(e.g),n,e.d),i;var i=e.f?_e.createElementNS(e.f,e.c):_e.createElement(e.c);ye&&"a"==e.c&&i.addEventListener("click",ye(i)),He(i,n,e.d);for(var c=e.e,l=0;l<c.length;l++)ze(i,je(1===r?c[l]:c[l].b,n));return i}function He(e,n,r){for(var t in r){var o=r[t];"a1"===t?Ie(e,o):"a0"===t?Ue(e,n,o):"a3"===t?We(e,o):"a4"===t?Oe(e,o):("value"!==t&&"checked"!==t||e[t]!==o)&&(e[t]=o)}}function Ie(e,n){var r=e.style;for(var t in n)r[t]=n[t]}function We(e,n){for(var r in n){var t=n[r];"undefined"!==typeof t?e.setAttribute(r,t):e.removeAttribute(r)}}function Oe(e,n){for(var r in n){var t=n[r],o=t.f,a=t.o;"undefined"!==typeof a?e.setAttributeNS(o,r,a):e.removeAttributeNS(o,r)}}function Ue(e,n,r){var t=e.elmFs||(e.elmFs={});for(var o in r){var a=r[o],i=t[o];if(a){if(i){if(i.q.$===a.$){i.q=a;continue}e.removeEventListener(o,i)}i=Ye(n,a),e.addEventListener(o,i,Ae&&{passive:Wr(a)<2}),t[o]=i}else e.removeEventListener(o,i),t[o]=void 0}}try{window.addEventListener("t",null,Object.defineProperty({},"passive",{get:function(){Ae=!0}}))}catch(e){}function Ye(e,n){function r(n){var t=r.q,o=X(t.a,n);if(Vr(o)){for(var a,i=Wr(t),c=o.a,l=i?i<3?c.a:c.as:c,u=1==i?c.b:3==i&&c.cP,f=(u&&n.stopPropagation(),(2==i?c.b:3==i&&c.cG)&&n.preventDefault(),e);a=f.j;){if("function"==typeof a)l=a(l);else for(var s=a.length;s--;)l=a[s](l);f=f.p}f(l,u)}}return r.q=n,r}function qe(e,n){return e.$==n.$&&ne(e.a,n.a)}function Ge(e,n,r,t){var o={$:n,r:r,s:t,t:void 0,u:void 0};return e.push(o),o}function Ze(e,n,r,t){if(e!==n){var o=e.$,a=n.$;if(o!==a){if(1!==o||2!==a)return void Ge(r,0,t,n);n=function(e){for(var n=e.e,r=n.length,t=Array(r),o=0;o<r;o++)t[o]=n[o].b;return{$:1,c:e.c,d:e.d,e:t,f:e.f,b:e.b}}(n),a=1}switch(a){case 5:for(var i=e.l,c=n.l,l=i.length,u=l===c.length;u&&l--;)u=i[l]===c[l];if(u)return void(n.k=e.k);n.k=n.m();var f=[];return Ze(e.k,n.k,f,0),void(f.length>0&&Ge(r,1,t,f));case 4:for(var s=e.j,d=n.j,m=!1,v=e.k;4===v.$;)m=!0,"object"!==typeof s?s=[s,v.j]:s.push(v.j),v=v.k;for(var p=n.k;4===p.$;)m=!0,"object"!==typeof d?d=[d,p.j]:d.push(p.j),p=p.k;return m&&s.length!==d.length?void Ge(r,0,t,n):((m?function(e,n){for(var r=0;r<e.length;r++)if(e[r]!==n[r])return!1;return!0}(s,d):s===d)||Ge(r,2,t,d),void Ze(v,p,r,t+1));case 0:return void(e.a!==n.a&&Ge(r,3,t,n.a));case 1:return void Xe(e,n,r,t,Je);case 2:return void Xe(e,n,r,t,Qe);case 3:if(e.h!==n.h)return void Ge(r,0,t,n);var g=Ke(e.d,n.d);g&&Ge(r,4,t,g);var b=n.i(e.g,n.g);return void(b&&Ge(r,5,t,b))}}}function Xe(e,n,r,t,o){if(e.c===n.c&&e.f===n.f){var a=Ke(e.d,n.d);a&&Ge(r,4,t,a),o(e,n,r,t)}else Ge(r,0,t,n)}function Ke(e,n,r){var t;for(var o in e)if("a1"!==o&&"a0"!==o&&"a3"!==o&&"a4"!==o)if(o in n){var a=e[o],i=n[o];a===i&&"value"!==o&&"checked"!==o||"a0"===r&&qe(a,i)||((t=t||{})[o]=i)}else(t=t||{})[o]=r?"a1"===r?"":"a0"===r||"a3"===r?void 0:{f:e[o].f,o:void 0}:"string"===typeof e[o]?"":null;else{var c=Ke(e[o],n[o]||{},o);c&&((t=t||{})[o]=c)}for(var l in n)l in e||((t=t||{})[l]=n[l]);return t}function Je(e,n,r,t){var o=e.e,a=n.e,i=o.length,c=a.length;i>c?Ge(r,6,t,{v:c,i:i-c}):i<c&&Ge(r,7,t,{v:i,e:a});for(var l=i<c?i:c,u=0;u<l;u++){var f=o[u];Ze(f,a[u],r,++t),t+=f.b||0}}function Qe(e,n,r,t){for(var o=[],a={},i=[],c=e.e,l=n.e,u=c.length,f=l.length,s=0,d=0,m=t;s<u&&d<f;){var v=(w=c[s]).a,p=(D=l[d]).a,g=w.b,b=D.b,h=void 0,C=void 0;if(v!==p){var x=c[s+1],T=l[d+1];if(x){var M=x.a,P=x.b;C=p===M}if(T){var y=T.a,L=T.b;h=v===y}if(h&&C)Ze(g,L,o,++m),nn(a,o,v,b,d,i),m+=g.b||0,rn(a,o,v,P,++m),m+=P.b||0,s+=2,d+=2;else if(h)m++,nn(a,o,p,b,d,i),Ze(g,L,o,m),m+=g.b||0,s+=1,d+=2;else if(C)rn(a,o,v,g,++m),m+=g.b||0,Ze(P,b,o,++m),m+=P.b||0,s+=2,d+=1;else{if(!x||M!==y)break;rn(a,o,v,g,++m),nn(a,o,p,b,d,i),m+=g.b||0,Ze(P,L,o,++m),m+=P.b||0,s+=2,d+=2}}else Ze(g,b,o,++m),m+=g.b||0,s++,d++}for(;s<u;){var w;rn(a,o,(w=c[s]).a,g=w.b,++m),m+=g.b||0,s++}for(;d<f;){var D,N=N||[];nn(a,o,(D=l[d]).a,D.b,void 0,N),d++}(o.length>0||i.length>0||N)&&Ge(r,8,t,{w:o,x:i,y:N})}var en="_elmW6BL";function nn(e,n,r,t,o,a){var i=e[r];if(!i)return a.push({r:o,A:i={c:0,z:t,r:o,s:void 0}}),void(e[r]=i);if(1===i.c){a.push({r:o,A:i}),i.c=2;var c=[];return Ze(i.z,t,c,i.r),i.r=o,void(i.s.s={w:c,A:i})}nn(e,n,r+en,t,o,a)}function rn(e,n,r,t,o){var a=e[r];if(a){if(0===a.c){a.c=2;var i=[];return Ze(t,a.z,i,o),void Ge(n,9,o,{w:i,A:a})}rn(e,n,r+en,t,o)}else{var c=Ge(n,9,o,void 0);e[r]={c:1,z:t,r:o,s:c}}}function tn(e,n,r,t){return 0===r.length?e:(function e(n,r,t,o){!function n(r,t,o,a,i,c,l){for(var u=o[a],f=u.r;f===i;){var s=u.$;if(1===s)e(r,t.k,u.s,l);else if(8===s)u.t=r,u.u=l,(d=u.s.w).length>0&&n(r,t,d,0,i,c,l);else if(9===s){u.t=r,u.u=l;var d,m=u.s;m&&(m.A.s=r,(d=m.w).length>0&&n(r,t,d,0,i,c,l))}else u.t=r,u.u=l;if(!(u=o[++a])||(f=u.r)>c)return a}var v=t.$;if(4===v){for(var p=t.k;4===p.$;)p=p.k;return n(r,p,o,a,i+1,c,r.elm_event_node_ref)}for(var g=t.e,b=r.childNodes,h=0;h<g.length;h++){i++;var C=1===v?g[h]:g[h].b,x=i+(C.b||0);if(i<=f&&f<=x&&(!(u=o[a=n(b[h],C,o,a,i,x,l)])||(f=u.r)>c))return a;i=x}return a}(n,r,t,0,0,r.b,o)}(e,n,r,t),on(e,r))}function on(e,n){for(var r=0;r<n.length;r++){var t=n[r],o=t.t,a=an(o,t);o===e&&(e=a)}return e}function an(e,n){switch(n.$){case 0:return function(e){var r=e.parentNode,t=je(n.s,n.u);return t.elm_event_node_ref||(t.elm_event_node_ref=e.elm_event_node_ref),r&&t!==e&&r.replaceChild(t,e),t}(e);case 4:return He(e,n.u,n.s),e;case 3:return e.replaceData(0,e.length,n.s),e;case 1:return on(e,n.s);case 2:return e.elm_event_node_ref?e.elm_event_node_ref.j=n.s:e.elm_event_node_ref={j:n.s,p:n.u},e;case 6:for(var r=n.s,t=0;t<r.i;t++)e.removeChild(e.childNodes[r.v]);return e;case 7:for(var o=(r=n.s).e,a=e.childNodes[t=r.v];t<o.length;t++)e.insertBefore(je(o[t],n.u),a);return e;case 9:if(!(r=n.s))return e.parentNode.removeChild(e),e;var i=r.A;return"undefined"!==typeof i.r&&e.parentNode.removeChild(e),i.s=on(e,r.w),e;case 8:return function(e,n){var r=n.s,t=function(e,n){if(e){for(var r=_e.createDocumentFragment(),t=0;t<e.length;t++){var o=e[t].A;ze(r,2===o.c?o.s:je(o.z,n.u))}return r}}(r.y,n);e=on(e,r.w);for(var o=r.x,a=0;a<o.length;a++){var i=o[a],c=i.A,l=2===c.c?c.s:je(c.z,n.u);e.insertBefore(l,e.childNodes[i.r])}return t&&ze(e,t),e}(e,n);case 5:return n.s(e);default:b(10)}}var cn=o(function(e,n,r,t){return function(e,n,r,t,o,a){var i=l(Z,e,te(n?n.flags:void 0));Vr(i)||b(2);var c={},u=r(i.a),f=u.a,s=a(m,f),d=function(e,n){var r;for(var t in be){var o=be[t];o.a&&((r=r||{})[t]=o.a(t,n)),e[t]=Ce(o,n)}return r}(c,m);function m(e,n){var r=l(t,e,f);s(f=r.a,n),De(c,r.b,o(f))}return De(c,u.b,o(f)),d?{ports:d}:{}}(n,t,e.eI,e.e3,e.e0,function(n,r){var o=e.e6,a=t.node,i=function e(n){if(3===n.nodeType)return $e(n.textContent);if(1!==n.nodeType)return $e("");for(var r=w,t=n.attributes,o=t.length;o--;){var a=t[o];r=D(l(ke,a.name,a.value),r)}var i=n.tagName.toLowerCase(),c=w,f=n.childNodes;for(o=f.length;o--;)c=D(e(f[o]),c);return u(Re,i,r,c)}(a);return function(e,n){n(e);var r=0;function t(){r=1===r?0:(un(t),n(e),1)}return function(o,a){e=o,a?(n(e),2===r&&(r=1)):(0===r&&un(t),r=2)}}(r,function(e){var r=o(e),t=function(e,n){var r=[];return Ze(e,n,r,0),r}(i,r);a=tn(a,i,t,n),i=r})})}),ln="undefined"!==typeof cancelAnimationFrame?cancelAnimationFrame:function(e){clearTimeout(e)},un="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:function(e){return setTimeout(e,1e3/60)};var fn={addEventListener:function(){},removeEventListener:function(){}},sn="undefined"!==typeof document?document:fn,dn="undefined"!==typeof window?window:fn,mn=t(function(e,n,r){return fe(ie(function(){function t(e){ue(r(e))}return e.addEventListener(n,t,Ae&&{passive:!0}),function(){e.removeEventListener(n,t)}}))}),vn=r(function(e,n){var r=X(e,n);return Vr(r)?sr(r.a):dr});var pn=r(function(e,n){return new Float64Array([e,n])});new Float64Array(3),new Float64Array(3),new Float64Array(3);var gn=t(function(e,n,r){return new Float64Array([e,n,r])}),bn=r(function(e,n){return new Float64Array([n[0]*e,n[1]*e,n[2]*e])}),hn=o(function(e,n,r,t){return new Float64Array([e,n,r,t])});new Float64Array(16),new Float64Array(16),new Float64Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);var Cn=0;function xn(e,n){for(;n.b;n=n.b)e(n.a)}function Tn(e){for(var n=0;e.b;e=e.b)n++;return n}var Mn="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:function(e){setTimeout(e,1e3/60)},Pn=a(function(e,n,r,t,o){return{$:0,a:e,b:n,c:r,d:t,e:o}}),yn=r(function(e,n){var r=e.blend;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.BLEND),r.enabled=!0),r.a===n.a&&r.d===n.d||(e.gl.blendEquationSeparate(n.a,n.d),r.a=n.a,r.d=n.d),r.b===n.b&&r.c===n.c&&r.e===n.e&&r.f===n.f||(e.gl.blendFuncSeparate(n.b,n.c,n.e,n.f),r.b=n.b,r.c=n.c,r.e=n.e,r.f=n.f),r.g===n.g&&r.h===n.h&&r.i===n.i&&r.j===n.j||(e.gl.blendColor(n.g,n.h,n.i,n.j),r.g=n.g,r.h=n.h,r.i=n.i,r.j=n.j)}),Ln=r(function(e,n){var r=e.depthTest;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.DEPTH_TEST),r.enabled=!0),r.a!==n.a&&(e.gl.depthFunc(n.a),r.a=n.a),r.b!==n.b&&(e.gl.depthMask(n.b),r.b=n.b),r.c===n.c&&r.d===n.d||(e.gl.depthRange(n.c,n.d),r.c=n.c,r.d=n.d)}),wn=r(function(e,n){var r=e.stencilTest;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.STENCIL_TEST),r.enabled=!0),r.d===n.d&&r.a===n.a&&r.b===n.b||(e.gl.stencilFuncSeparate(e.gl.FRONT,n.d,n.a,n.b),r.d=n.d),r.e===n.e&&r.f===n.f&&r.g===n.g||(e.gl.stencilOpSeparate(e.gl.FRONT,n.e,n.f,n.g),r.e=n.e,r.f=n.f,r.g=n.g),r.c!==n.c&&(e.gl.stencilMask(n.c),r.c=n.c),r.h===n.h&&r.a===n.a&&r.b===n.b||(e.gl.stencilFuncSeparate(e.gl.BACK,n.h,n.a,n.b),r.h=n.h,r.a=n.a,r.b=n.b),r.i===n.i&&r.j===n.j&&r.k===n.k||(e.gl.stencilOpSeparate(e.gl.BACK,n.i,n.j,n.k),r.i=n.i,r.j=n.j,r.k=n.k)}),Dn=r(function(e,n){var r=e.scissor;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SCISSOR_TEST),r.enabled=!0),r.a===n.a&&r.b===n.b&&r.c===n.c&&r.d===n.d||(e.gl.scissor(n.a,n.b,n.c,n.d),r.a=n.a,r.b=n.b,r.c=n.c,r.d=n.d)}),Nn=r(function(e,n){var r=e.colorMask;r.toggle=e.toggle,r.enabled=!0,r.a===n.a&&r.b===n.b&&r.c===n.c&&r.d===n.d||(e.gl.colorMask(n.a,n.b,n.c,n.d),r.a=n.a,r.b=n.b,r.c=n.c,r.d=n.d)}),Sn=r(function(e,n){var r=e.cullFace;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.CULL_FACE),r.enabled=!0),r.a!==n.a&&(e.gl.cullFace(n.a),r.a=n.a)}),_n=r(function(e,n){var r=e.polygonOffset;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.POLYGON_OFFSET_FILL),r.enabled=!0),r.a===n.a&&r.b===n.b||(e.gl.polygonOffset(n.a,n.b),r.a=n.a,r.b=n.b)}),zn=r(function(e,n){var r=e.sampleCoverage;r.toggle=e.toggle,r.enabled||(e.gl.enable(e.gl.SAMPLE_COVERAGE),r.enabled=!0),r.a===n.a&&r.b===n.b||(e.gl.sampleCoverage(n.a,n.b),r.a=n.a,r.b=n.b)}),$n=function(e){e.scissor.enabled&&(e.gl.disable(e.gl.SCISSOR_TEST),e.scissor.enabled=!1)},An=function(e){var n=e.colorMask;n.a&&n.b&&n.c&&n.d||(e.gl.colorMask(!0,!0,!0,!0),n.a=!0,n.b=!0,n.c=!0,n.d=!0)},Rn=["blend","depthTest","stencilTest","scissor","colorMask","cullFace","polygonOffset","sampleCoverage","sampleAlphaToCoverage"],Fn=[function(e){e.blend.enabled&&(e.gl.disable(e.gl.BLEND),e.blend.enabled=!1)},function(e){e.depthTest.enabled&&(e.gl.disable(e.gl.DEPTH_TEST),e.depthTest.enabled=!1)},function(e){e.stencilTest.enabled&&(e.gl.disable(e.gl.STENCIL_TEST),e.stencilTest.enabled=!1)},$n,An,function(e){e.gl.disable(e.gl.CULL_FACE)},function(e){e.gl.disable(e.gl.POLYGON_OFFSET_FILL)},function(e){e.gl.disable(e.gl.SAMPLE_COVERAGE)},function(e){e.gl.disable(e.gl.SAMPLE_ALPHA_TO_COVERAGE)}];function Bn(e,n,r){var t=e.createShader(r);return e.shaderSource(t,"#extension GL_OES_standard_derivatives : enable\n"+n),e.compileShader(t),t}function kn(e,n){switch(n){case e.FLOAT:return{size:1,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC2:return{size:2,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC3:return{size:3,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_VEC4:return{size:4,arraySize:1,type:Float32Array,baseType:e.FLOAT};case e.FLOAT_MAT4:return{size:4,arraySize:4,type:Float32Array,baseType:e.FLOAT};case e.INT:return{size:1,arraySize:1,type:Int32Array,baseType:e.INT}}}function En(e,n,r,t){for(var o=r.a.c1,a=[],i=0;i<o;i++)a.push(String.fromCharCode(97+i));var c=kn(e,n.type);if(void 0===c)throw Error("No info available for: "+n.type);var l=0,u=c.size*c.arraySize*o,f=new c.type(Tn(r.b)*u);xn(function(e){!function(e,n,r,t,i){var c;if(1===o)for(c=0;c<n;c++)e[r++]=1===n?t[i]:t[i][c];else a.forEach(function(o){for(c=0;c<n;c++)e[r++]=1===n?t[o][i]:t[o][i][c]})}(f,c.size*c.arraySize,l,e,t[n.name]||n.name),l+=u},r.b);var s=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,s),e.bufferData(e.ARRAY_BUFFER,f,e.STATIC_DRAW),s}function Vn(e,n){return e+"#"+n}var jn=r(function(e,n){var r=e.f,t=r.gl;return t?(t.viewport(0,0,t.drawingBufferWidth,t.drawingBufferHeight),r.depthTest.b||(t.depthMask(!0),r.depthTest.b=!0),r.stencilTest.c!==r.STENCIL_WRITEMASK&&(t.stencilMask(r.STENCIL_WRITEMASK),r.stencilTest.c=r.STENCIL_WRITEMASK),$n(r),An(r),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT|t.STENCIL_BUFFER_BIT),xn(function(n){if(n.d.b.b){var o,a,i,c,l;if(n.b.id&&n.c.id&&(o=Vn(n.b.id,n.c.id),a=r.programs[o]),!a){var u,f;n.b.id?u=r.shaders[n.b.id]:n.b.id=Cn++,u||(u=Bn(t,n.b.src,t.VERTEX_SHADER),r.shaders[n.b.id]=u),n.c.id?f=r.shaders[n.c.id]:n.c.id=Cn++,f||(f=Bn(t,n.c.src,t.FRAGMENT_SHADER),r.shaders[n.c.id]=f);var s=function(e,n,r){var t=e.createProgram();if(e.attachShader(t,n),e.attachShader(t,r),e.linkProgram(t),!e.getProgramParameter(t,e.LINK_STATUS))throw"Link failed: "+e.getProgramInfoLog(t)+"\nvs info-log: "+e.getShaderInfoLog(n)+"\nfs info-log: "+e.getShaderInfoLog(r);return t}(t,u,f);(a={glProgram:s,attributes:Object.assign({},n.b.attributes,n.c.attributes),currentUniforms:{},activeAttributes:[],activeAttributeLocations:[]}).uniformSetters=function(e,n,r,t){var o=r.glProgram,a=r.currentUniforms,i=0,c=n.f;function l(n,r){var t=r.name,o=e.getUniformLocation(n,t);switch(r.type){case e.INT:return function(n){a[t]!==n&&(e.uniform1i(o,n),a[t]=n)};case e.FLOAT:return function(n){a[t]!==n&&(e.uniform1f(o,n),a[t]=n)};case e.FLOAT_VEC2:return function(n){a[t]!==n&&(e.uniform2f(o,n[0],n[1]),a[t]=n)};case e.FLOAT_VEC3:return function(n){a[t]!==n&&(e.uniform3f(o,n[0],n[1],n[2]),a[t]=n)};case e.FLOAT_VEC4:return function(n){a[t]!==n&&(e.uniform4f(o,n[0],n[1],n[2],n[3]),a[t]=n)};case e.FLOAT_MAT4:return function(n){a[t]!==n&&(e.uniformMatrix4fv(o,!1,new Float32Array(n)),a[t]=n)};case e.SAMPLER_2D:var l=i++;return function(n){e.activeTexture(e.TEXTURE0+l);var r=c.textures.get(n);r||(r=n.el(e),c.textures.set(n,r)),e.bindTexture(e.TEXTURE_2D,r),a[t]!==n&&(e.uniform1i(o,l),a[t]=n)};case e.BOOL:return function(n){a[t]!==n&&(e.uniform1i(o,n),a[t]=n)};default:return function(){}}}for(var u={},f=e.getProgramParameter(o,e.ACTIVE_UNIFORMS),s=0;s<f;s++){var d=e.getActiveUniform(o,s);u[t[d.name]||d.name]=l(o,d)}return u}(t,e,a,Object.assign({},n.b.uniforms,n.c.uniforms));var d=t.getProgramParameter(s,t.ACTIVE_ATTRIBUTES);for(i=0;i<d;i++){var m=t.getActiveAttrib(s,i),v=t.getAttribLocation(s,m.name);a.activeAttributes.push(m),a.activeAttributeLocations.push(v)}o=Vn(n.b.id,n.c.id),r.programs[o]=a}r.lastProgId!==o&&(t.useProgram(a.glProgram),r.lastProgId=o),c=a.uniformSetters,Object.keys(l=n.e).forEach(function(e){var n=c[e];n&&n(l[e])});var p=r.buffers.get(n.d);for(p||(p=function(e,n){if(n.a.c9>0){var r=e.createBuffer(),t=function(e,n){var r,t=new Uint32Array(Tn(e)*n),o=0;return xn(function(e){if(1===n)t[o++]=e;else for(r=0;r<n;r++)t[o++]=e[String.fromCharCode(97+r)]},e),t}(n.c,n.a.c9);return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r),e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW),{numIndices:t.length,indexBuffer:r,buffers:{}}}return{numIndices:n.a.c1*Tn(n.b),indexBuffer:null,buffers:{}}}(t,n.d),r.buffers.set(n.d,p)),i=0;i<a.activeAttributes.length;i++){v=a.activeAttributeLocations[i],void 0===p.buffers[(m=a.activeAttributes[i]).name]&&(p.buffers[m.name]=En(t,m,n.d,a.attributes)),t.bindBuffer(t.ARRAY_BUFFER,p.buffers[m.name]);var g=kn(t,m.type);if(1===g.arraySize)t.enableVertexAttribArray(v),t.vertexAttribPointer(v,g.size,g.baseType,!1,0,0);else for(var b=4*g.size,h=b*g.arraySize,C=0;C<g.arraySize;C++)t.enableVertexAttribArray(v+C),t.vertexAttribPointer(v+C,g.size,g.baseType,!1,h,b*C)}for(r.toggle=!r.toggle,xn(Ea(r),n.a),i=0;i<9;i++){var x=r[Rn[i]];x.toggle!==r.toggle&&x.enabled&&(Fn[i](r),x.enabled=!1,x.toggle=r.toggle)}p.indexBuffer?(t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,p.indexBuffer),t.drawElements(n.d.a.dH,p.numIndices,t.UNSIGNED_INT,0)):t.drawArrays(n.d.a.dH,0,p.numIndices)}},e.g),n):n}),Hn=t(function(e,n,r){return function(e,n,r,t){return{$:3,d:Ee(e),g:n,h:r,i:t}}(n,{g:r,f:{},h:e},Gn,Zn)}),In=r(function(e,n){e.contextAttributes.alpha=!0,e.contextAttributes.premultipliedAlpha=n.a}),Wn=r(function(e,n){e.contextAttributes.depth=!0,e.sceneSettings.push(function(e){e.clearDepth(n.a)})}),On=r(function(e,n){e.contextAttributes.stencil=!0,e.sceneSettings.push(function(e){e.clearStencil(n.a)})}),Un=r(function(e){e.contextAttributes.antialias=!0}),Yn=r(function(e,n){e.sceneSettings.push(function(e){e.clearColor(n.a,n.b,n.c,n.d)})}),qn=r(function(e){e.contextAttributes.preserveDrawingBuffer=!0});function Gn(e){var n={contextAttributes:{alpha:!1,depth:!1,stencil:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1},sceneSettings:[]};xn(function(e){return l(ka,n,e)},e.h);var r=_e.createElement("canvas"),t=r.getContext&&(r.getContext("webgl",n.contextAttributes)||r.getContext("experimental-webgl",n.contextAttributes));return t&&"undefined"!==typeof WeakMap?(n.sceneSettings.forEach(function(e){e(t)}),t.getExtension("OES_standard_derivatives"),t.getExtension("OES_element_index_uint"),e.f.gl=t,e.f.toggle=!1,e.f.blend={enabled:!1,toggle:!1},e.f.depthTest={enabled:!1,toggle:!1},e.f.stencilTest={enabled:!1,toggle:!1},e.f.scissor={enabled:!1,toggle:!1},e.f.colorMask={enabled:!1,toggle:!1},e.f.cullFace={enabled:!1,toggle:!1},e.f.polygonOffset={enabled:!1,toggle:!1},e.f.sampleCoverage={enabled:!1,toggle:!1},e.f.sampleAlphaToCoverage={enabled:!1,toggle:!1},e.f.shaders=[],e.f.programs={},e.f.lastProgId=null,e.f.buffers=new WeakMap,e.f.textures=new WeakMap,e.f.STENCIL_WRITEMASK=t.getParameter(t.STENCIL_WRITEMASK),Mn(function(){return l(jn,e,r)})):(r=_e.createElement("div")).innerHTML='<a href="https://get.webgl.org/">Enable WebGL</a> to see this content!',r}function Zn(e,n){return n.f=e.f,jn(n)}var Xn=N,Kn=t(function(e,n,r){for(;;){if(-2===r.$)return n;var t=r.d,o=e,a=u(e,r.b,r.c,u(Kn,e,n,r.e));e=o,n=a,r=t}}),Jn=function(e){return u(Kn,t(function(e,n,r){return l(Xn,M(e,n),r)}),w,e)},Qn=1,er=2,nr=0,rr=r(function(e,n){return{$:1,a:e,b:n}}),tr=r(function(e){return e}),or=function(e){return{$:1,a:e}},ar=r(function(e,n){return{$:3,a:e,b:n}}),ir=r(function(e,n){return{$:0,a:e,b:n}}),cr=r(function(e,n){return{$:1,a:e,b:n}}),lr=function(e){return{$:0,a:e}},ur=function(e){return{$:2,a:e}},fr=z,sr=function(e){return{$:0,a:e}},dr={$:1},mr=I,vr=r(function(e,n){return l(H,e,function(e){for(var n=[];e.b;e=e.b)n.push(e.a);return n}(n))}),pr=t(function(e,n,r){for(;;){if(!r.b)return n;var t=r.b,o=e,a=l(e,r.a,n);e=o,n=a,r=t}}),gr=function(e){return u(pr,r(function(e,n){return n+1}),0,e)},br=_,hr=t(function(e,n,r){for(;;){if(x(e,n)>=1)return r;var t=e,o=n-1,a=l(Xn,n,r);e=t,n=o,r=a}}),Cr=r(function(e,n){return u(hr,e,n,w)}),xr=r(function(e,n){return u(br,e,l(Cr,0,gr(n)-1),n)}),Tr=function(e){return u(pr,Xn,w,e)},Mr=o(function(e,n,r,t){return{$:0,a:e,b:n,c:r,d:t}}),Pr=[],yr=B,Lr=r(function(e,n){return j(n)/j(e)}),wr=yr(l(Lr,2,32)),Dr=f(Mr,0,wr,Pr,Pr),Nr=v,Sr=function(e){return{$:1,a:e}},_r=k,zr=function(e){return e.length},$r=r(function(e,n){return x(e,n)>0?e:n}),Ar=p,Rr=r(function(e,n){for(;;){var r=l(Ar,32,e),t=r.b,o=l(Xn,{$:0,a:r.a},n);if(!t.b)return Tr(o);e=t,n=o}}),Fr=r(function(e,n){for(;;){var r=yr(n/32);if(1===r)return l(Ar,32,e).a;e=l(Rr,e,w),n=r}}),Br=r(function(e,n){if(n.m){var r=32*n.m,t=_r(l(Lr,32,r-1)),o=e?Tr(n.A):n.A,a=l(Fr,o,n.m);return f(Mr,zr(n.q)+r,l($r,5,t*wr),a,n.q)}return f(Mr,zr(n.q),wr,Pr,n.q)}),kr=a(function(e,n,r,t,o){for(;;){if(n<0)return l(Br,!1,{A:t,m:r/32|0,q:o});var a=Sr(u(Nr,32,n,e));e=e,n-=32,r=r,t=l(Xn,a,t),o=o}}),Er=r(function(e,n){if(e>0){var r=e%32;return s(kr,n,e-r-32,e,w,u(Nr,r,e-r,n))}return Dr}),Vr=function(e){return!e.$},jr=Pe,Hr=q,Ir=G,Wr=function(e){switch(e.$){case 0:return 0;case 1:return 1;case 2:return 2;default:return 3}},Or=function(e){return e},Ur=ae,Yr=Ur(0),qr=o(function(e,n,r,t){if(t.b){var o=t.a,a=t.b;if(a.b){var i=a.a,c=a.b;if(c.b){var s=c.a,d=c.b;if(d.b){var m=d.b;return l(e,o,l(e,i,l(e,s,l(e,d.a,r>500?u(pr,e,n,Tr(m)):f(qr,e,n,r+1,m)))))}return l(e,o,l(e,i,l(e,s,n)))}return l(e,o,l(e,i,n))}return l(e,o,n)}return n}),Gr=t(function(e,n,r){return f(qr,e,n,0,r)}),Zr=r(function(e,n){return u(Gr,r(function(n,r){return l(Xn,e(n),r)}),w,n)}),Xr=ce,Kr=r(function(e,n){return l(Xr,function(n){return Ur(e(n))},n)}),Jr=t(function(e,n,r){return l(Xr,function(n){return l(Xr,function(r){return Ur(l(e,n,r))},r)},n)}),Qr=function(e){return u(Gr,Jr(Xn),Ur(w),e)},et=xe,nt=r(function(e,n){var r=n;return fe(l(Xr,et(e),r))});be.Task=he(Yr,t(function(e,n){return l(Kr,function(){return 0},Qr(l(Zr,nt(e),n)))}),t(function(){return Ur(0)}),r(function(e,n){return l(Kr,e,n)}));var rt,tt=Me("Task"),ot=cn,at=E,it=M({bk:500,bl:500,bs:0},l(r(function(e,n){return tt(l(Kr,e,n))}),function(e){var n=e.e8;return l(rr,at(n.fa),at(n.eE))},(rt=function(){return{dX:(e=sn.body,n=sn.documentElement,{fa:Math.max(e.scrollWidth,e.offsetWidth,n.scrollWidth,n.offsetWidth,n.clientWidth),eE:Math.max(e.scrollHeight,e.offsetHeight,n.scrollHeight,n.offsetHeight,n.clientHeight)}),e8:{d6:dn.pageXOffset,d7:dn.pageYOffset,fa:sn.documentElement.clientWidth,eE:sn.documentElement.clientHeight}};var e,n},ie(function(e){un(function(){e(ae(rt()))})})))),ct=function(e){return{$:1,a:e}},lt=t(function(e,n,r){return{cv:r,dU:n,d_:e}}),ut=Ur(u(lt,w,dr,0)),ft=function(e){return ie(function(n){var r=e.f;2===r.$&&r.c&&r.c(),e.f=null,n(ae(0))})},st=ie(function(e){e(ae(Date.now()))}),dt=ie(function(e){var n=un(function(){e(ae(Date.now()))});return function(){ln(n)}}),mt=Te,vt=fe,pt=t(function(e,n,r){var t=r.dU,o=r.cv,a=M(t,n);return 1===a.a.$?a.b.b?l(Xr,function(e){return l(Xr,function(r){return Ur(u(lt,n,sr(e),r))},st)},vt(l(Xr,mt(e),dt))):ut:a.b.b?Ur(u(lt,n,t,o)):l(Xr,function(){return ut},ft(a.a.a))}),gt=Or,bt=t(function(e,n,r){var t=r.d_,o=r.cv,a=function(r){return l(et,e,(0,r.a)(r.$?n-o:gt(n)))};return l(Xr,function(e){return l(Xr,function(){return Ur(u(lt,t,sr(e),n))},Qr(l(Zr,a,t)))},vt(l(Xr,mt(e),dt)))}),ht=t(function(e,n,r){return e(n(r))});be["Browser.AnimationManager"]=he(ut,pt,bt,0,r(function(e,n){return n.$?ct(l(ht,e,n.a)):{$:0,a:l(ht,e,n.a)}}));var Ct=Me("Browser.AnimationManager"),xt=U,Tt=O,Mt=t(function(e,n,r){return{$:0,a:e,b:n,c:r}}),Pt=r(function(e,n){return{dM:n,d_:e}}),yt={$:-2},Lt=yt,wt=Ur(l(Pt,w,Lt)),Dt=function(e){return M(L(e.a?"w_":"d_",e.b),e)},Nt=a(function(e,n,r,t,o){return{$:-1,a:e,b:n,c:r,d:t,e:o}}),St=a(function(e,n,r,t,o){if(-1!==o.$||o.a){if(-1!==t.$||t.a||-1!==t.d.$||t.d.a)return s(Nt,e,n,r,t,o);var a=t.d;return i=t.e,s(Nt,0,t.b,t.c,s(Nt,1,a.b,a.c,a.d,a.e),s(Nt,1,n,r,i,o))}var i,c=o.b,l=o.c,u=o.d,f=o.e;return-1!==t.$||t.a?s(Nt,e,c,l,s(Nt,0,n,r,t,u),f):s(Nt,0,n,r,s(Nt,1,t.b,t.c,t.d,i=t.e),s(Nt,1,c,l,u,f))}),_t=T,zt=t(function(e,n,r){if(-2===r.$)return s(Nt,0,e,n,yt,yt);var t=r.a,o=r.b,a=r.c,i=r.d,c=r.e;switch(l(_t,e,o)){case 0:return s(St,t,o,a,u(zt,e,n,i),c);case 1:return s(Nt,t,o,n,i,c);default:return s(St,t,o,a,i,u(zt,e,n,c))}}),$t=t(function(e,n,r){var t=u(zt,e,n,r);return-1!==t.$||t.a?t:s(Nt,1,t.b,t.c,t.d,t.e)}),At=function(e){return u(pr,r(function(e,n){return u($t,e.a,e.b,n)}),Lt,e)},Rt=t(function(e,n,r){for(;;){if(-2===r.$)return n;var t=r.e,o=e,a=u(e,r.b,r.c,u(Rt,e,n,r.d));e=o,n=a,r=t}}),Ft=i(function(e,n,o,a,i,c){var l=u(Rt,t(function(r,t,a){e:for(;;){var i=a.a,c=a.b;if(i.b){var l=i.a,s=l.a,d=l.b,m=i.b;if(x(s,r)<0){r=r,t=t,a=M(m,u(e,s,d,c));continue e}return x(s,r)>0?M(i,u(o,r,t,c)):M(m,f(n,s,d,t,c))}return M(i,u(o,r,t,c))}}),M(Jn(a),c),i),s=l.a,d=l.b;return u(pr,r(function(n,r){return u(e,n.a,n.b,r)}),d,s)}),Bt=r(function(e,n){return{c4:n,db:e}}),kt=t(function(e,n,r){return l(Kr,function(e){return M(n,e)},u(mn,r.a?dn:sn,r.b,function(r){return l(mt,e,l(Bt,n,r))}))}),Et=r(function(e,n){return u(Rt,$t,n,e)}),Vt=t(function(e,n,r){var a=t(function(n,r,t){var o=t.c;return P(t.a,t.b,l(Xn,u(kt,e,n,r),o))}),i=t(function(e,n,r){var t=r.b,o=r.c;return P(l(Xn,n,r.a),t,o)}),c=o(function(e,n,r,t){var o=t.c;return P(t.a,u($t,e,n,t.b),o)}),f=l(Zr,Dt,n),s=d(Ft,i,c,a,r.dM,At(f),P(w,Lt,w)),m=s.b,v=s.c;return l(Xr,function(e){return Ur(l(Pt,f,l(Et,m,At(e))))},l(Xr,function(){return Qr(v)},Qr(l(Zr,ft,s.a))))}),jt=t(function(e,n,r){var t=e(n);return t.$?r:l(Xn,t.a,r)}),Ht=r(function(e,n){return u(Gr,jt(e),w,n)});be["Browser.Events"]=he(wt,Vt,t(function(e,n,r){var t=n.db,o=n.c4,a=l(Ht,function(e){var n=e.b.c;return h(e.a,t)?l(vn,n,o):dr},r.d_);return l(Xr,function(){return Ur(r)},Qr(l(Zr,et(e),a)))}),0,r(function(e,n){return u(Mt,n.a,n.b,l(Hr,e,n.c))}));var It,Wt,Ot,Ut,Yt,qt,Gt,Zt,Xt,Kt,Jt,Qt,eo,no,ro,to,oo,ao,io,co,lo,uo,fo=Me("Browser.Events"),so=t(function(e,n,r){return fo(u(Mt,e,n,r))}),mo=Pe(w),vo=r(function(e,n){switch(e.$){case 0:return M(n,mo);case 1:return M(y(n,{bk:e.a,bl:e.b}),mo);default:return M(y(n,{bs:n.bs+e.a}),mo)}}),po=r(function(e,n){var r=n;return function(n){var t=r(n),o=t.b;return e(t.a)(o)}}),go=o(function(e,n,r,t){return{$:2,a:e,b:n,c:r,d:t}}),bo=o(function(e,n,r,t){return{$:3,a:e,b:n,c:r,d:t}}),ho=o(function(e,n,r,t){return{$:4,a:e,b:n,c:r,d:t}}),Co=o(function(e,n,r,t){return{$:6,a:e,b:n,c:r,d:t}}),xo=o(function(e,n,r,t){return{$:7,a:e,b:n,c:r,d:t}}),To=o(function(e,n,r,t){return{$:5,a:e,b:n,c:r,d:t}}),Mo=o(function(e,n,r,t){return{$:1,a:e,b:n,c:r,d:t}}),Po={$:0},yo=function(e){return e},Lo=r(function(e,n){return l($r,e,n)}),wo=r(function(e,n){return x(e,n)<0?e:n}),Do=r(function(e,n){return l(wo,e,n)}),No=c(function(e,n,r,t,o,a,i,c){for(;;){if(!c.b)return{dA:n,dB:t,dC:a,dD:e,dE:r,dF:o};var u=c.b,f=yo(i(c.a));e=l(Do,f.dD,e),n=l(Lo,f.dA,n),r=l(Do,f.dE,r),t=l(Lo,f.dB,t),o=l(Do,f.dF,o),a=l(Lo,f.dC,a),i=i,c=u}}),So=t(function(e,n,r){var t=yo(e(n));return m(No,t.dD,t.dA,t.dE,t.dB,t.dF,t.dC,e,r)}),_o=r(function(e,n){return x(n,e)<1}),zo=function(e){return e},$o=function(e){return e.d6},Ao=function(e){return e.d7},Ro=function(e){return e.b5},Fo=function(e){var n,r=zo(e),t=r.a,o=r.b,a=r.c,i=$o(t),c=Ao(t),u=Ro(t),f=$o(o),s=Ao(o),d=Ro(o),m=$o(a),v=Ao(a),p=Ro(a);return l(_o,(n={dA:l(Lo,i,l(Lo,f,m)),dB:l(Lo,c,l(Lo,s,v)),dC:l(Lo,u,l(Lo,d,p)),dD:l(Do,i,l(Do,f,m)),dE:l(Do,c,l(Do,s,v)),dF:l(Do,u,l(Do,d,p))}).dA,n.dD)&&l(_o,n.dB,n.dE)&&l(_o,n.dC,n.dF)?n:{dA:l(Lo,n.dD,n.dA),dB:l(Lo,n.dE,n.dB),dC:l(Lo,n.dF,n.dC),dD:l(Do,n.dD,n.dA),dE:l(Do,n.dE,n.dB),dF:l(Do,n.dF,n.dC)}},Bo=function(e){return new Float64Array([e.d6,e.d7,e.b5])},ko=function(e){return e},Eo=function(e){return Bo(ko(e))},Vo=function(e){return Bo(e)},jo=r(function(e,n){return{d6:n.d7*e.b5-n.b5*e.d7,d7:n.b5*e.d6-n.d6*e.b5,b5:n.d6*e.d7-n.d7*e.d6}}),Ho=r(function(e,n){return{d6:n.d6-e.d6,d7:n.d7-e.d7,b5:n.b5-e.b5}}),Io=function(e){return e},Wo=function(e){return e<0?-e:e},Oo=V,Uo={d6:0,d7:0,b5:0},Yo=r(function(e,n){var r=e,t=n,o=l($r,Wo(t.d6),l($r,Wo(t.d7),Wo(t.b5)));if(o){var a=t.b5/o,i=t.d7/o,c=t.d6/o,u=Oo(c*c+i*i+a*a);return{d6:r*c/u,d7:r*i/u,b5:r*a/u}}return Uo})(Io(1)),qo=t(function(e,n,r){return Yo(l(jo,l(Ho,n,r),l(Ho,e,n)))}),Go=function(e){var n=zo(e),r=n.a,t=n.b,o=n.c,a=Vo(u(qo,r,t,o));return P({p:a,bZ:Eo(r)},{p:a,bZ:Eo(t)},{p:a,bZ:Eo(o)})},Zo=r(function(e,n){return{$:2,a:e,b:n}})({c1:3,c9:0,dH:4}),Xo=t(function(e,n,r){return P(e,n,r)}),Ko=function(e){return e},Jo=r(function(e,n){return e*n}),Qo=t(function(e,n,r){return{d6:e,d7:n,b5:r}}),ea=(It=Ko(1),Wt=Ko(1),Ot=Ko(1),Ut=l(Jo,-.5,It),Yt=l(Jo,-.5,Wt),Gt=u(Qo,qt=l(Jo,-.5,Ot),Yt,Ut),Xt=u(Qo,qt,Yt,Zt=l(Jo,.5,It)),Jt=u(Qo,qt,Kt=l(Jo,.5,Wt),Ut),Qt=u(Qo,qt,Kt,Zt),no=u(Qo,eo=l(Jo,.5,Ot),Yt,Ut),ro=u(Qo,eo,Kt,Ut),to=u(Qo,eo,Yt,Zt),oo=u(Qo,eo,Kt,Zt),function(e){switch(e.$){case 0:return e;case 1:return f(Mo,e.a,e.b,e.c,1);case 2:return f(go,e.a,e.b,e.c,1);case 3:return f(bo,e.a,e.b,e.c,1);case 4:return f(ho,e.a,e.b,e.c,1);case 5:return f(To,e.a,e.b,e.c,1);case 6:return f(Co,e.a,e.b,e.c,1);case 7:return f(xo,e.a,e.b,e.c,1);case 8:case 9:default:return e}}(function(e){if(e.b){var n=e.a,r=e.b,t=Zo(l(Zr,Go,e));return f(go,u(So,Fo,n,r),e,t,0)}return Po}(S([u(Xo,Gt,ro,no),u(Xo,Gt,Jt,ro),u(Xo,Xt,to,oo),u(Xo,Xt,oo,Qt),u(Xo,no,ro,oo),u(Xo,no,oo,to),u(Xo,Gt,Qt,Jt),u(Xo,Gt,Xt,Qt),u(Xo,Gt,no,to),u(Xo,Gt,to,Xt),u(Xo,Jt,oo,ro),u(Xo,Jt,Qt,oo)])))),na={$:0},ra=t(function(e,n,r){return{$:1,a:e,b:n,c:r}}),ta=t(function(e,n,r){var t=n.a,o=n.b,a=e(n.c),i=e(o),c=e(t),f=Vo(u(qo,c,i,a)),s={p:f,bZ:Eo(c)},d={p:f,bZ:Eo(i)},m={p:f,bZ:Eo(a)};return l(Xn,s,l(Xn,d,l(Xn,m,r)))}),oa=o(function(e,n,r,t){return 1===n.$?dr:1===r.$?dr:1===t.$?dr:sr(u(e,n.a,r.a,t.a))}),aa=4294967295>>>32-wr,ia=g,ca=t(function(e,n,r){for(;;){var t=l(ia,aa&n>>>e,r);if(t.$)return l(ia,aa&n,t.a);e-=wr,n=n,r=t.a}}),la=r(function(e,n){var r=n.a,t=n.b,o=n.c,a=n.d;return e<0||x(e,r)>-1?dr:x(e,function(e){return e>>>5<<5}(r))>-1?sr(l(ia,aa&e,a)):sr(u(ca,t,e,o))}),ua=r(function(e,n){return l(la,e,n.am)}),fa=t(function(e,n,r){for(;;){var t=l(Ar,32,e),o=t.a,a=t.b;if(x(zr(o),32)<0)return l(Br,!0,{A:n,m:r,q:o});e=a,n=l(Xn,Sr(o),n),r+=1}}),sa=function(e){return e.b?u(fa,e,w,0):Dr},da=r(function(e,n){for(;;){if(!n.b)return!1;var r=n.b;if(e(n.a))return!0;e=e,n=r}}),ma=function(e){return!e},va=r(function(e,n){return!l(da,l(ht,ma,e),n)}),pa=r(function(e,n){return u(Gr,r(function(n,r){return e(n)?l(Xn,n,r):r}),w,n)}),ga=r(function(e,n){var r=e.a,t=function(e){var n=e.a,t=e.b,o=e.c;return n>=0&&x(n,r)<0&&t>=0&&x(t,r)<0&&o>=0&&x(o,r)<0};return l(va,t,n)?{E:n,am:e}:{E:l(pa,t,n),am:e}}),ba=t(function(e,n,r){return{$:3,a:e,b:n,c:r}})({c1:1,c9:3,dH:4}),ha=function(e){return e},Ca=r(function(e,n){var r=ha(n),t=ha(e);return M(P(t.d6,t.d7,t.b5),P(r.d6,r.d7,r.b5))}),xa=r(function(e,n){e:for(;;){if(-2===n.$)return dr;var r=n.c,t=n.d,o=n.e;switch(l(_t,e,n.b)){case 0:e=e,n=t;continue e;case 1:return sr(r);default:e=e,n=o;continue e}}}),Ta=gn,Ma=u(Ta,0,0,0),Pa=i(function(e,n,r,t,o,a){var i=a.a,c=a.b,u=a.c,f=l(xa,l(Ca,e,n),o);if(f.$){var s={p:Ma,bZ:Eo(n)},d={p:Ma,bZ:Eo(e)},m=u+1;return P(l(Xn,P(r,u,m),l(Xn,P(r,m,t),i)),l(Xn,s,l(Xn,d,c)),u+2)}return P(l(Xn,P(r,f.a,t),i),c,u)}),ya=a(function(e,n,r,t,o){for(;;){if(!r.b)return M(o.a,Tr(o.b));var a=r.a,i=a.a,c=a.b,l=r.b,u=e(a.c),f=e(c),s=e(i),m=t+2,v=t+1,p=e,g=n,b=l,h=t+3,C=d(Pa,u,s,m,t,n,d(Pa,f,u,v,m,n,d(Pa,s,f,t,v,n,o)));e=p,n=g,r=b,t=h,o=C}}),La=a(function(e,n,r,t,o){for(;;){if(!n.b)return P(t,o,r);var a=n.a,i=a.a,c=a.b,f=n.b,s=e(a.c),d=e(c),m=e(i),v=r+2,p=r+1,g=r,b=u($t,l(Ca,m,s),v,u($t,l(Ca,s,d),p,u($t,l(Ca,d,m),g,o)));e=e,n=f,r+=3,t=l(Xn,P(g,p,v),t),o=b}}),wa=t(function(e,n,r){var o,a=l(Ht,function(e){var n=e.a,r=e.b,a=e.c;return f(oa,t(function(e,n,r){return P(e,n,r)}),l(ua,n,o),l(ua,r,o),l(ua,a,o))},(o=r).E),i=u(Gr,ta(n),w,a),c=s(La,n,a,0,w,Lt),d=s(ya,n,c.b,a,0,P(c.a,w,c.c)),m=d.a,v=d.b,p=v.b?L(i,v):i;return u(ra,e,l(ga,sa(p),m),l(ba,p,m))}),Da=r(function(e,n){return n.b?u(Gr,Xn,n,e):e}),Na=function(e){return u(Gr,Da,w,e)},Sa=function(e){switch(e.$){case 0:return na;case 1:case 2:return u(wa,e.a,Or,{E:l(Zr,function(e){return P(3*e,3*e+1,3*e+2)},l(Cr,0,gr(n=l(Zr,zo,e.b))-1)),am:sa(Na(l(Zr,function(e){return S([e.a,e.b,e.c])},n)))});case 3:return u(wa,e.a,Or,e.b);case 4:case 5:case 6:case 7:return u(wa,e.a,function(e){return e.bZ},e.b);case 8:case 9:default:return na}var n}(ea),_a={$:0},za=_a,$a=function(e){return{$:4,a:e}},Aa=r(function(e,n){for(;;){if(!e.b)return n;var r=e.a;e=e.b,n=l(Xn,r,n)}}),Ra=function(e){return $a(l(Aa,e,w))},Fa=r(function(e,n){return{$:1,a:e,b:n}}),Ba={src:"\n        precision mediump float;\n        \n        uniform mediump sampler2D colorTexture;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        void main () {\n            gl_FragColor = texture2D(colorTexture, interpolatedUv);\n        }\n    ",attributes:{},uniforms:{colorTexture:"bH"}},ka=r(function(e,n){switch(n.$){case 0:return l(In,e,n);case 1:return l(Wn,e,n);case 2:return l(On,e,n);case 3:return l(Un,e,n);case 4:return l(Yn,e,n);default:return l(qn,e,n)}}),Ea=r(function(e,n){switch(n.$){case 0:return l(yn,e,n);case 1:return l(Ln,e,n);case 2:return l(wn,e,n);case 3:return l(Dn,e,n);case 4:return l(Nn,e,n);case 5:return l(Sn,e,n);case 6:return l(_n,e,n);case 7:return l(zn,e,n);default:return function(e){var n=e.sampleAlphaToCoverage;n.toggle=e.toggle,n.enabled||(e.gl.enable(e.gl.SAMPLE_ALPHA_TO_COVERAGE),n.enabled=!0)}(e)}}),Va=Pn,ja=function(e){return{$:5,a:e}},Ha=ja(1029),Ia=ja(1028),Wa=t(function(e,n,r){return 1===n?l(Xn,e?Ha:Ia,r):r}),Oa={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute mediump vec2 uv;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main() {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedUv = uv;\n        }\n    ",attributes:{position:"bZ",uv:"M"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},Ua=o(function(e,n,r,t){return l(Fa,n,c(function(n,o,a,i,c,l,f,d){return s(Va,u(Wa,i,t,d),Oa,Ba,r,{bH:e,b:a,c:o,d:l,e:n,f:c})}))}),Ya={src:"\n        precision lowp float;\n        \n        uniform lowp vec3 constantColor;\n        \n        void main () {\n            gl_FragColor = vec4(constantColor, 1.0);\n        }\n    ",attributes:{},uniforms:{constantColor:"aD"}},qa={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n        }\n    ",attributes:{position:"bZ"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},Ga=o(function(e,n,r,t){return l(Fa,n,c(function(n,o,a,i,c,l,f,d){return s(Va,u(Wa,i,t,d),qa,Ya,r,{aD:e,b:a,c:o,d:l,e:n,f:c})}))}),Za=r(function(e,n){return{$:3,a:e,b:n}}),Xa={src:"\n        precision lowp float;\n        \n        uniform lowp vec3 constantColor;\n        uniform lowp float pointRadius;\n        uniform highp mat4 sceneProperties;\n        \n        float pointAlpha(float pointRadius, vec2 pointCoord) {\n            float pointSize = 2.0 * pointRadius;\n            float x = (pointSize + 2.0) * (pointCoord.s - 0.5);\n            float y = (pointSize + 2.0) * (pointCoord.t - 0.5);\n            float r = sqrt(x * x + y * y);\n            float innerRadius = pointRadius;\n            float outerRadius = pointRadius + 1.0;\n            if (r > outerRadius) {\n                return 0.0;\n            } else if (r > innerRadius) {\n                return outerRadius - r;\n            } else {\n                return 1.0;\n            }\n        }\n        \n        void main () {\n            float supersampling = sceneProperties[3][0];\n            float alpha = pointAlpha(pointRadius * supersampling, gl_PointCoord);\n            gl_FragColor = vec4(constantColor, alpha);\n        }\n    ",attributes:{},uniforms:{constantColor:"aD",pointRadius:"bY",sceneProperties:"e"}},Ka={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform lowp float pointRadius;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            float supersampling = sceneProperties[3][0];\n            gl_PointSize = 2.0 * pointRadius * supersampling + 2.0;\n        }\n    ",attributes:{position:"bZ"},uniforms:{modelMatrix:"b",modelScale:"c",pointRadius:"bY",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},Ja=o(function(e,n,r,t){return l(Za,r,c(function(r,o,a,i,c,l,u,f){return s(Va,f,Ka,Xa,t,{aD:e,b:a,c:o,bY:n,d:l,e:r,f:c})}))}),Qa={src:"\n        precision mediump float;\n        \n        uniform mediump vec3 emissiveColor;\n        uniform highp mat4 sceneProperties;\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main () {\n            gl_FragColor = toSrgb(emissiveColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{emissiveColor:"aO",sceneProperties:"e"}},ei=function(e){return e},ni=bn,ri=a(function(e,n,r,t,o){return l(Fa,r,c(function(r,a,i,c,f,d,m,v){return s(Va,u(Wa,c,o,v),qa,Qa,t,{aO:l(ni,ei(n),e),b:i,c:a,d:d,e:r,f:f})}))}),ti={src:"\n        precision mediump float;\n        \n        uniform mediump vec3 emissiveColor;\n        uniform lowp float pointRadius;\n        uniform highp mat4 sceneProperties;\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        float pointAlpha(float pointRadius, vec2 pointCoord) {\n            float pointSize = 2.0 * pointRadius;\n            float x = (pointSize + 2.0) * (pointCoord.s - 0.5);\n            float y = (pointSize + 2.0) * (pointCoord.t - 0.5);\n            float r = sqrt(x * x + y * y);\n            float innerRadius = pointRadius;\n            float outerRadius = pointRadius + 1.0;\n            if (r > outerRadius) {\n                return 0.0;\n            } else if (r > innerRadius) {\n                return outerRadius - r;\n            } else {\n                return 1.0;\n            }\n        }\n        \n        void main () {\n            vec4 color = toSrgb(emissiveColor, sceneProperties);\n            float supersampling = sceneProperties[3][0];\n            float alpha = pointAlpha(pointRadius * supersampling, gl_PointCoord);\n            gl_FragColor = vec4(color.rgb, alpha);\n        }\n    ",attributes:{},uniforms:{emissiveColor:"aO",pointRadius:"bY",sceneProperties:"e"}},oi=a(function(e,n,r,t,o){return l(Za,t,c(function(t,a,i,c,u,f,d,m){return s(Va,m,Ka,ti,o,{aO:l(ni,ei(n),e),b:i,c:a,bY:r,d:f,e:t,f:u})}))}),ai={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform lowp vec3 materialColor;\n        uniform highp mat4 viewMatrix;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 lambertianLight(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                vec3 upDirection = xyz_type.xyz;\n                vec3 aboveLuminance = rgb_parameter.rgb;\n                vec3 belowLuminance = rgb_parameter.a * aboveLuminance;\n                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, surfaceNormal);\n                return luminance * materialColor;\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(\n                xyz_type,\n                rgb_parameter,\n                surfacePosition,\n                directionToLight,\n                normalIlluminance\n            );\n        \n            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);\n            return (normalIlluminance * dotNL) * (materialColor / kPi);\n        }\n        \n        vec3 lambertianLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            vec3 litColor1 = enabledLights[0] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[0], lights12[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[2], lights12[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[0], lights34[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[2], lights34[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[0], lights56[1]);\n            vec3 litColor6 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[2], lights56[3]);\n            vec3 litColor7 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[0], lights78[1]);\n            vec3 litColor8 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[2], lights78[3]);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 normalDirection = normalize(interpolatedNormal) * getNormalSign();\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = lambertianLighting(\n                interpolatedPosition,\n                normalDirection,\n                materialColor,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{enabledLights:"T",lights12:"bd",lights34:"bP",lights56:"bQ",lights78:"bR",materialColor:"co",sceneProperties:"e",viewMatrix:"f"}},ii={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute highp vec3 normal;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n        }\n    ",attributes:{normal:"p",position:"bZ"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},ci=o(function(e,n,r,t){return l(Fa,n,c(function(n,o,a,i,c,l,f,d){var m=f.a,v=f.b;return s(Va,u(Wa,i,t,d),ii,ai,r,{T:v,bd:m.bd,bP:m.bP,bQ:m.bQ,bR:m.bR,co:e,b:a,c:o,d:l,e:n,f:c})}))}),li={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform mediump sampler2D materialColorTexture;\n        uniform mediump sampler2D normalMapTexture;\n        uniform lowp float useNormalMap;\n        uniform highp mat4 viewMatrix;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {\n            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);\n            float x = 2.0 * (rgb.r - 0.5);\n            float y = 2.0 * (rgb.g - 0.5);\n            float z = 2.0 * (rgb.b - 0.5);\n            return normalize(vec3(-x, -y, z));\n        }\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getMappedNormal(vec3 normal, vec3 tangent, float normalSign, vec3 localNormal) {\n            vec3 bitangent = cross(normal, tangent) * normalSign;\n            return normalize(localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal);\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 lambertianLight(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                vec3 upDirection = xyz_type.xyz;\n                vec3 aboveLuminance = rgb_parameter.rgb;\n                vec3 belowLuminance = rgb_parameter.a * aboveLuminance;\n                vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, upDirection, surfaceNormal);\n                return luminance * materialColor;\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(\n                xyz_type,\n                rgb_parameter,\n                surfacePosition,\n                directionToLight,\n                normalIlluminance\n            );\n        \n            float dotNL = positiveDotProduct(directionToLight, surfaceNormal);\n            return (normalIlluminance * dotNL) * (materialColor / kPi);\n        }\n        \n        vec3 lambertianLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 materialColor,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            vec3 litColor1 = enabledLights[0] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[0], lights12[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights12[2], lights12[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[0], lights34[1]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? lambertianLight(surfacePosition, surfaceNormal, materialColor, lights34[2], lights34[3]) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[0], lights56[1]);\n            vec3 litColor6 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights56[2], lights56[3]);\n            vec3 litColor7 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[0], lights78[1]);\n            vec3 litColor8 = lambertianLight(surfacePosition, surfaceNormal, materialColor, lights78[2], lights78[3]);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);\n            float normalSign = getNormalSign();\n            vec3 originalNormal = normalize(interpolatedNormal) * normalSign;\n            vec3 normalDirection = getMappedNormal(originalNormal, interpolatedTangent, normalSign, localNormal);\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n            vec3 materialColor = fromSrgb(texture2D(materialColorTexture, interpolatedUv).rgb);\n        \n            vec3 linearColor = lambertianLighting(\n                interpolatedPosition,\n                normalDirection,\n                materialColor,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{enabledLights:"T",lights12:"bd",lights34:"bP",lights56:"bQ",lights78:"bR",materialColorTexture:"cp",normalMapTexture:"aV",sceneProperties:"e",useNormalMap:"a_",viewMatrix:"f"}},ui={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute highp vec3 normal;\n        attribute mediump vec2 uv;\n        attribute highp vec3 tangent;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        vec3 getWorldTangent(vec3 modelTangent, vec4 modelScale, mat4 modelMatrix) {\n            return (modelMatrix * vec4(safeNormalize(modelScale.xyz * modelTangent), 0.0)).xyz;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n            interpolatedUv = uv;\n            interpolatedTangent = getWorldTangent(tangent, modelScale, modelMatrix);\n        }\n    ",attributes:{normal:"p",position:"bZ",tangent:"d1",uv:"M"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},fi=i(function(e,n,r,t,o,a){return l(Fa,t,c(function(t,i,c,l,f,d,m,v){var p=m.a,g=m.b;return s(Va,u(Wa,l,a,v),ui,li,o,{T:g,bd:p.bd,bP:p.bP,bQ:p.bQ,bR:p.bR,cp:e,b:c,c:i,aV:n,d:d,e:t,a_:r,f:f})}))}),si={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform mediump sampler2D baseColorTexture;\n        uniform lowp vec4 constantBaseColor;\n        uniform mediump sampler2D roughnessTexture;\n        uniform lowp vec2 constantRoughness;\n        uniform mediump sampler2D metallicTexture;\n        uniform lowp vec2 constantMetallic;\n        uniform mediump sampler2D normalMapTexture;\n        uniform lowp float useNormalMap;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const mediump float kMediumpFloatMax = 65504.0;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getFloatValue(sampler2D texture, vec2 uv, vec2 constantValue) {\n            if (constantValue.y == 1.0) {\n                return constantValue.x;\n            } else {\n                vec4 textureColor = texture2D(texture, uv);\n                return dot(textureColor, vec4(0.2126, 0.7152, 0.0722, 0.0));\n            }\n        }\n        \n        vec3 getLocalNormal(sampler2D normalMap, float useNormalMap, vec2 uv) {\n            vec3 rgb = useNormalMap * texture2D(normalMap, uv).rgb + (1.0 - useNormalMap) * vec3(0.5, 0.5, 1.0);\n            float x = 2.0 * (rgb.r - 0.5);\n            float y = 2.0 * (rgb.g - 0.5);\n            float z = 2.0 * (rgb.b - 0.5);\n            return normalize(vec3(-x, -y, z));\n        }\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getMappedNormal(vec3 normal, vec3 tangent, float normalSign, vec3 localNormal) {\n            vec3 bitangent = cross(normal, tangent) * normalSign;\n            return normalize(localNormal.x * tangent + localNormal.y * bitangent + localNormal.z * normal);\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)\n        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {\n            vec3 crossNH = cross(normalDirection, halfDirection);\n            float a = dotNH * alpha;\n            float k = alpha / (dot(crossNH, crossNH) + a * a);\n            float d = k * k * (1.0 / kPi);\n            return min(d, kMediumpFloatMax);\n        }\n        \n        float safeQuotient(float numerator, float denominator) {\n            if (denominator == 0.0) {\n                return 0.0;\n            } else {\n                return numerator / denominator;\n            }\n        }\n        \n        float g1(float dotNV, float alphaSquared) {\n            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));\n        }\n        \n        float specularG(float dotNL, float dotNV, float alphaSquared) {\n            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);\n        }\n        \n        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {\n            vec3 one = vec3(1.0, 1.0, 1.0);\n            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\n            return specularBaseColor + (one - specularBaseColor) * scale;\n        }\n        \n        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {\n            vec3 halfDirection = normalize(directionToCamera + directionToLight);\n            float dotVH = positiveDotProduct(directionToCamera, halfDirection);\n            float dotNH = positiveDotProduct(normalDirection, halfDirection);\n            float dotNHSquared = dotNH * dotNH;\n        \n            float d = specularD(alpha, dotNH, normalDirection, halfDirection);\n            float g = specularG(dotNL, dotNV, alpha * alpha);\n            vec3 f = fresnelColor(specularBaseColor, dotVH);\n            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;\n        }\n        \n        vec3 sampleFacetNormal(vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {\n            float t2 = (1.0 - s);\n            vec3 vNh = t2 * vT2 + sqrt(max(0.0, 1.0 - t2 * t2)) * vH;\n            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 softLightingSpecularSample(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localViewDirection,\n            vec3 localLightDirection,\n            vec3 localHalfDirection,\n            float alphaSquared,\n            vec3 specularBaseColor\n        ) {\n            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);\n            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);\n            float dotNL = localLightDirection.z;\n            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));\n        }\n        \n        vec3 softLighting(\n            vec3 normalDirection,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha,\n            vec3 directionToCamera,\n            vec3 viewY,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float alphaSquared = alpha * alpha;\n            vec3 upDirection = xyz_type.xyz;\n            vec3 luminanceAbove = rgb_parameter.rgb;\n            vec3 luminanceBelow = rgb_parameter.a * luminanceAbove;\n            vec3 crossProduct = cross(normalDirection, directionToCamera);\n            float crossMagnitude = length(crossProduct);\n            vec3 xDirection = vec3(0.0, 0.0, 0.0);\n            vec3 yDirection = vec3(0.0, 0.0, 0.0);\n            if (crossMagnitude > 1.0e-6) {\n                yDirection = (1.0 / crossMagnitude) * crossProduct;\n                xDirection = cross(yDirection, normalDirection);\n            } else {\n                vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n                xDirection = normalize(cross(viewY, normalDirection));\n                yDirection = cross(normalDirection, xDirection);\n            }\n            float localViewX = dot(directionToCamera, xDirection);\n            float localViewZ = dot(directionToCamera, normalDirection);\n            vec3 localViewDirection = vec3(localViewX, 0, localViewZ);\n            float localUpX = dot(upDirection, xDirection);\n            float localUpY = dot(upDirection, yDirection);\n            float localUpZ = dot(upDirection, normalDirection);\n            vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);\n        \n            vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));\n            vec3 vT1 = vec3(0.0, 1.0, 0.0);\n            vec3 vT2 = cross(vH, vT1);\n            float s = 0.5 * (1.0 + vH.z);\n            \n            vec3 localHalfDirection = sampleFacetNormal(vH, vT1, vT2, s, alpha);\n            vec3 localLightDirection = vec3(0.0, 0.0, 0.0);\n            \n            localLightDirection = -reflect(localViewDirection, localHalfDirection);\n            vec3 specular = softLightingSpecularSample(luminanceAbove, luminanceBelow, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);\n            \n            localLightDirection = vec3(0.000000, 0.000000, 1.000000);\n            vec3 diffuse = softLightingLuminance(luminanceAbove, luminanceBelow, localUpDirection, localLightDirection) * localLightDirection.z;\n            \n            return specular + diffuse * diffuseBaseColor;\n        }\n        \n        vec3 physicalLight(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            vec3 normalDirection,\n            vec3 directionToCamera,\n            vec3 viewY,\n            float dotNV,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                return softLighting(normalDirection, diffuseBaseColor, specularBaseColor, alpha, directionToCamera, viewY, xyz_type, rgb_parameter);\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_parameter, surfacePosition, directionToLight, normalIlluminance);\n        \n            float dotNL = positiveDotProduct(normalDirection, directionToLight);\n            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);\n            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);\n        }\n        \n        vec3 physicalLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 baseColor,\n            vec3 directionToCamera,\n            mat4 viewMatrix,\n            float roughness,\n            float metallic,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);\n            float alpha = roughness * roughness;\n            float nonmetallic = 1.0 - metallic;\n            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;\n            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;\n            vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n        \n            vec3 litColor1 = enabledLights[0] == 1.0 ? physicalLight(lights12[0], lights12[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? physicalLight(lights12[2], lights12[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? physicalLight(lights34[0], lights34[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? physicalLight(lights34[2], lights34[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = physicalLight(lights56[0], lights56[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor6 = physicalLight(lights56[2], lights56[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor7 = physicalLight(lights78[0], lights78[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor8 = physicalLight(lights78[2], lights78[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 baseColor = fromSrgb(texture2D(baseColorTexture, interpolatedUv).rgb) * (1.0 - constantBaseColor.w) + constantBaseColor.rgb * constantBaseColor.w;\n            float roughness = getFloatValue(roughnessTexture, interpolatedUv, constantRoughness);\n            float metallic = getFloatValue(metallicTexture, interpolatedUv, constantMetallic);\n        \n            vec3 localNormal = getLocalNormal(normalMapTexture, useNormalMap, interpolatedUv);\n            float normalSign = getNormalSign();\n            vec3 originalNormal = normalize(interpolatedNormal) * normalSign;\n            vec3 normalDirection = getMappedNormal(originalNormal, interpolatedTangent, normalSign, localNormal);\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = physicalLighting(\n                interpolatedPosition,\n                normalDirection,\n                baseColor,\n                directionToCamera,\n                viewMatrix,\n                roughness,\n                metallic,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{baseColorTexture:"b8",constantBaseColor:"ca",constantMetallic:"cb",constantRoughness:"cc",enabledLights:"T",lights12:"bd",lights34:"bP",lights56:"bQ",lights78:"bR",metallicTexture:"cs",normalMapTexture:"aV",roughnessTexture:"cM",sceneProperties:"e",useNormalMap:"a_",viewMatrix:"f"}},di={src:"\n        precision highp float;\n        \n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 lights12;\n        uniform highp mat4 lights34;\n        uniform highp mat4 lights56;\n        uniform highp mat4 lights78;\n        uniform lowp vec4 enabledLights;\n        uniform lowp vec3 baseColor;\n        uniform lowp float roughness;\n        uniform lowp float metallic;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        \n        const lowp float kPerspectiveProjection = 0.0;\n        const lowp float kOrthographicProjection = 1.0;\n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        const highp float kPi = 3.14159265359;\n        const mediump float kMediumpFloatMax = 65504.0;\n        const lowp float kDisabledLight = 0.0;\n        const lowp float kSoftLighting = 3.0;\n        \n        float getNormalSign() {\n            return 2.0 * float(gl_FrontFacing) - 1.0;\n        }\n        \n        vec3 getDirectionToCamera(vec3 surfacePosition, mat4 sceneProperties) {\n            float projectionType = sceneProperties[1].w;\n            if (projectionType == kPerspectiveProjection) {\n                vec3 cameraPoint = sceneProperties[1].xyz;\n                return normalize(cameraPoint - surfacePosition);\n            } else if (projectionType == kOrthographicProjection) {\n                return sceneProperties[1].xyz;\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        void getDirectionToLightAndNormalIlluminance(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            out vec3 directionToLight,\n            out vec3 normalIlluminance\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                directionToLight = xyz_type.xyz;\n                normalIlluminance = rgb_parameter.rgb;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                vec3 displacement = lightPosition - surfacePosition;\n                float distance = length(displacement);\n                directionToLight = displacement / distance;\n                normalIlluminance = rgb_parameter.rgb / (4.0 * kPi * distance * distance);\n            }\n        }\n        \n        float positiveDotProduct(vec3 v1, vec3 v2) {\n            return clamp(dot(v1, v2), 0.0, 1.0);\n        }\n        \n        // Adapted from https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/normaldistributionfunction(speculard)\n        float specularD(float alpha, float dotNH, vec3 normalDirection, vec3 halfDirection) {\n            vec3 crossNH = cross(normalDirection, halfDirection);\n            float a = dotNH * alpha;\n            float k = alpha / (dot(crossNH, crossNH) + a * a);\n            float d = k * k * (1.0 / kPi);\n            return min(d, kMediumpFloatMax);\n        }\n        \n        float safeQuotient(float numerator, float denominator) {\n            if (denominator == 0.0) {\n                return 0.0;\n            } else {\n                return numerator / denominator;\n            }\n        }\n        \n        float g1(float dotNV, float alphaSquared) {\n            return safeQuotient(2.0 * dotNV, dotNV + sqrt(alphaSquared + (1.0 - alphaSquared) * dotNV * dotNV));\n        }\n        \n        float specularG(float dotNL, float dotNV, float alphaSquared) {\n            return g1(dotNV, alphaSquared) * g1(dotNL, alphaSquared);\n        }\n        \n        vec3 fresnelColor(vec3 specularBaseColor, float dotVH) {\n            vec3 one = vec3(1.0, 1.0, 1.0);\n            float scale = exp2((-5.55473 * dotVH - 6.98316) * dotVH);\n            return specularBaseColor + (one - specularBaseColor) * scale;\n        }\n        \n        vec3 brdf(vec3 normalDirection, vec3 directionToCamera, vec3 directionToLight, float alpha, float dotNV, float dotNL, vec3 specularBaseColor, vec3 normalIlluminance) {\n            vec3 halfDirection = normalize(directionToCamera + directionToLight);\n            float dotVH = positiveDotProduct(directionToCamera, halfDirection);\n            float dotNH = positiveDotProduct(normalDirection, halfDirection);\n            float dotNHSquared = dotNH * dotNH;\n        \n            float d = specularD(alpha, dotNH, normalDirection, halfDirection);\n            float g = specularG(dotNL, dotNV, alpha * alpha);\n            vec3 f = fresnelColor(specularBaseColor, dotVH);\n            return safeQuotient(d * g, 4.0 * dotNL * dotNV) * f;\n        }\n        \n        vec3 sampleFacetNormal(vec3 vH, vec3 vT1, vec3 vT2, float s, float alpha) {\n            float t2 = (1.0 - s);\n            vec3 vNh = t2 * vT2 + sqrt(max(0.0, 1.0 - t2 * t2)) * vH;\n            return normalize(vec3(alpha * vNh.x, alpha * vNh.y, max(0.0, vNh.z)));\n        }\n        \n        vec3 softLightingLuminance(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localLightDirection\n        ) {\n            float sinElevation = dot(localLightDirection, localUpDirection);\n            float t = (sinElevation + 1.0) / 2.0;\n            return aboveLuminance * t + belowLuminance * (1.0 - t);\n        }\n        \n        vec3 softLightingSpecularSample(\n            vec3 aboveLuminance,\n            vec3 belowLuminance,\n            vec3 localUpDirection,\n            vec3 localViewDirection,\n            vec3 localLightDirection,\n            vec3 localHalfDirection,\n            float alphaSquared,\n            vec3 specularBaseColor\n        ) {\n            vec3 luminance = softLightingLuminance(aboveLuminance, belowLuminance, localUpDirection, localLightDirection);\n            float dotVH = positiveDotProduct(localViewDirection, localHalfDirection);\n            float dotNL = localLightDirection.z;\n            return luminance * (fresnelColor(specularBaseColor, dotVH) * g1(dotNL, alphaSquared));\n        }\n        \n        vec3 softLighting(\n            vec3 normalDirection,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha,\n            vec3 directionToCamera,\n            vec3 viewY,\n            vec4 xyz_type,\n            vec4 rgb_parameter\n        ) {\n            float alphaSquared = alpha * alpha;\n            vec3 upDirection = xyz_type.xyz;\n            vec3 luminanceAbove = rgb_parameter.rgb;\n            vec3 luminanceBelow = rgb_parameter.a * luminanceAbove;\n            vec3 crossProduct = cross(normalDirection, directionToCamera);\n            float crossMagnitude = length(crossProduct);\n            vec3 xDirection = vec3(0.0, 0.0, 0.0);\n            vec3 yDirection = vec3(0.0, 0.0, 0.0);\n            if (crossMagnitude > 1.0e-6) {\n                yDirection = (1.0 / crossMagnitude) * crossProduct;\n                xDirection = cross(yDirection, normalDirection);\n            } else {\n                vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n                xDirection = normalize(cross(viewY, normalDirection));\n                yDirection = cross(normalDirection, xDirection);\n            }\n            float localViewX = dot(directionToCamera, xDirection);\n            float localViewZ = dot(directionToCamera, normalDirection);\n            vec3 localViewDirection = vec3(localViewX, 0, localViewZ);\n            float localUpX = dot(upDirection, xDirection);\n            float localUpY = dot(upDirection, yDirection);\n            float localUpZ = dot(upDirection, normalDirection);\n            vec3 localUpDirection = vec3(localUpX, localUpY, localUpZ);\n        \n            vec3 vH = normalize(vec3(alpha * localViewX, 0.0, localViewZ));\n            vec3 vT1 = vec3(0.0, 1.0, 0.0);\n            vec3 vT2 = cross(vH, vT1);\n            float s = 0.5 * (1.0 + vH.z);\n            \n            vec3 localHalfDirection = sampleFacetNormal(vH, vT1, vT2, s, alpha);\n            vec3 localLightDirection = vec3(0.0, 0.0, 0.0);\n            \n            localLightDirection = -reflect(localViewDirection, localHalfDirection);\n            vec3 specular = softLightingSpecularSample(luminanceAbove, luminanceBelow, localUpDirection, localViewDirection, localLightDirection, localHalfDirection, alphaSquared, specularBaseColor);\n            \n            localLightDirection = vec3(0.000000, 0.000000, 1.000000);\n            vec3 diffuse = softLightingLuminance(luminanceAbove, luminanceBelow, localUpDirection, localLightDirection) * localLightDirection.z;\n            \n            return specular + diffuse * diffuseBaseColor;\n        }\n        \n        vec3 physicalLight(\n            vec4 xyz_type,\n            vec4 rgb_parameter,\n            vec3 surfacePosition,\n            vec3 normalDirection,\n            vec3 directionToCamera,\n            vec3 viewY,\n            float dotNV,\n            vec3 diffuseBaseColor,\n            vec3 specularBaseColor,\n            float alpha\n        ) {\n            float lightType = xyz_type.w;\n            if (lightType == kDisabledLight) {\n                return vec3(0.0, 0.0, 0.0);\n            } else if (lightType == kSoftLighting) {\n                return softLighting(normalDirection, diffuseBaseColor, specularBaseColor, alpha, directionToCamera, viewY, xyz_type, rgb_parameter);\n            }\n        \n            vec3 directionToLight = vec3(0.0, 0.0, 0.0);\n            vec3 normalIlluminance = vec3(0.0, 0.0, 0.0);\n            getDirectionToLightAndNormalIlluminance(xyz_type, rgb_parameter, surfacePosition, directionToLight, normalIlluminance);\n        \n            float dotNL = positiveDotProduct(normalDirection, directionToLight);\n            vec3 specularColor = brdf(normalDirection, directionToCamera, directionToLight, alpha, dotNV, dotNL, specularBaseColor, normalIlluminance);\n            return (normalIlluminance * dotNL) * ((diffuseBaseColor / kPi) + specularColor);\n        }\n        \n        vec3 physicalLighting(\n            vec3 surfacePosition,\n            vec3 surfaceNormal,\n            vec3 baseColor,\n            vec3 directionToCamera,\n            mat4 viewMatrix,\n            float roughness,\n            float metallic,\n            mat4 lights12,\n            mat4 lights34,\n            mat4 lights56,\n            mat4 lights78,\n            vec4 enabledLights\n        ) {\n            float dotNV = positiveDotProduct(surfaceNormal, directionToCamera);\n            float alpha = roughness * roughness;\n            float nonmetallic = 1.0 - metallic;\n            vec3 diffuseBaseColor = nonmetallic * 0.96 * baseColor;\n            vec3 specularBaseColor = nonmetallic * 0.04 * vec3(1.0, 1.0, 1.0) + metallic * baseColor;\n            vec3 viewY = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n        \n            vec3 litColor1 = enabledLights[0] == 1.0 ? physicalLight(lights12[0], lights12[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor2 = enabledLights[1] == 1.0 ? physicalLight(lights12[2], lights12[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor3 = enabledLights[2] == 1.0 ? physicalLight(lights34[0], lights34[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor4 = enabledLights[3] == 1.0 ? physicalLight(lights34[2], lights34[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha) : vec3(0.0, 0.0, 0.0);\n            vec3 litColor5 = physicalLight(lights56[0], lights56[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor6 = physicalLight(lights56[2], lights56[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor7 = physicalLight(lights78[0], lights78[1], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            vec3 litColor8 = physicalLight(lights78[2], lights78[3], surfacePosition, surfaceNormal, directionToCamera, viewY, dotNV, diffuseBaseColor, specularBaseColor, alpha);\n            return litColor1 + litColor2 + litColor3 + litColor4 + litColor5 + litColor6 + litColor7 + litColor8;\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main() {\n            vec3 normalDirection = normalize(interpolatedNormal) * getNormalSign();\n            vec3 directionToCamera = getDirectionToCamera(interpolatedPosition, sceneProperties);\n        \n            vec3 linearColor = physicalLighting(\n                interpolatedPosition,\n                normalDirection,\n                baseColor,\n                directionToCamera,\n                viewMatrix,\n                roughness,\n                metallic,\n                lights12,\n                lights34,\n                lights56,\n                lights78,\n                enabledLights\n            );\n        \n            gl_FragColor = toSrgb(linearColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{baseColor:"ee",enabledLights:"T",lights12:"bd",lights34:"bP",lights56:"bQ",lights78:"bR",metallic:"cr",roughness:"eX",sceneProperties:"e",viewMatrix:"f"}},mi=i(function(e,n,r,t,o,a){return l(Fa,t,c(function(t,i,c,l,f,d,m,v){var p=m.a,g=m.b;return s(Va,u(Wa,l,a,v),ii,di,o,{ee:e,T:g,bd:p.bd,bP:p.bP,bQ:p.bQ,bR:p.bR,cr:r,b:c,c:i,d:d,eX:n,e:t,f:f})}))}),vi=r(function(e,n){return{$:1,a:e,b:n}}),pi=r(function(e,n){return n.$?M(n.a.D,1):M(e,0)}),gi=function(e){return e[0]},bi=function(e){return e[1]},hi=function(e){return e[2]},Ci=hn,xi=f(Ci,0,0,0,0),Ti=r(function(e,n){var r;return n.$?M(n.a.D,xi):M(e,f(Ci,gi(r=n.a),bi(r),hi(r),1))}),Mi=r(function(e,n){var r,t=M(e,n);return t.a.$?l(vi,M(r=t.a.a.D,xi),l(pi,r,n)):t.b.$?l(vi,l(Ti,r=t.b.a.D,e),l(pi,r,n)):{$:0,a:t.a.a}}),Pi=t(function(e,n,r){return{$:0,a:e,b:n,c:r}}),yi=o(function(e,n,r,t){return{$:1,a:e,b:n,c:r,d:t}}),Li=o(function(e,n,r,t){return{$:0,a:e,b:n,c:r,d:t}}),wi=pn,Di=l(wi,0,0),Ni=r(function(e,n){return n.$?M(n.a.D,Di):M(e,l(wi,n.a,1))}),Si=o(function(e,n,r,t){var o,a=f(Li,e,n,r,t);return a.a.$?f(yi,M(o=a.a.a.D,xi),l(Ni,o,n),l(Ni,o,r),l(pi,o,t)):a.b.$?f(yi,l(Ti,o=a.b.a.D,e),M(o,Di),l(Ni,o,r),l(pi,o,t)):a.c.$?f(yi,l(Ti,o=a.c.a.D,e),l(Ni,o,n),M(o,Di),l(pi,o,t)):a.d.$?f(yi,l(Ti,o=a.d.a.D,e),l(Ni,o,n),l(Ni,o,r),M(o,1)):u(Pi,a.a.a,a.b.a,a.c.a)}),_i={src:"\n        precision mediump float;\n        \n        uniform mediump sampler2D colorTexture;\n        uniform mediump float backlight;\n        uniform highp mat4 sceneProperties;\n        \n        varying mediump vec2 interpolatedUv;\n        \n        float inverseGamma(float u) {\n            if (u <= 0.04045) {\n                return clamp(u / 12.92, 0.0, 1.0);\n            } else {\n                return clamp(pow((u + 0.055) / 1.055, 2.4), 0.0, 1.0);\n            }\n        }\n        \n        vec3 fromSrgb(vec3 srgbColor) {\n            return vec3(\n                inverseGamma(srgbColor.r),\n                inverseGamma(srgbColor.g),\n                inverseGamma(srgbColor.b)\n            );\n        }\n        \n        float gammaCorrect(float u) {\n            if (u <= 0.0031308) {\n                return 12.92 * u;\n            } else {\n                return 1.055 * pow(u, 1.0 / 2.4) - 0.055;\n            }\n        }\n        \n        vec3 gammaCorrectedColor(vec3 color) {\n            float red = gammaCorrect(color.r);\n            float green = gammaCorrect(color.g);\n            float blue = gammaCorrect(color.b);\n            return vec3(red, green, blue);\n        }\n        \n        vec3 reinhardLuminanceToneMap(vec3 color) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scale = 1.0 / (1.0 + luminance);\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 reinhardPerChannelToneMap(vec3 color) {\n            return gammaCorrectedColor(color / (color + 1.0));\n        }\n        \n        float extendedReinhardToneMap(float x, float xMax) {\n            return x * (1.0 + (x / (xMax * xMax))) / (1.0 + x);\n        }\n        \n        vec3 extendedReinhardLuminanceToneMap(vec3 color, float overexposureLimit) {\n            float luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n            float scaledLuminance = extendedReinhardToneMap(luminance, overexposureLimit);\n            float scale = scaledLuminance / luminance;\n            return gammaCorrectedColor(color * scale);\n        }\n        \n        vec3 extendedReinhardPerChannelToneMap(vec3 color, float overexposureLimit) {\n            float red = extendedReinhardToneMap(color.r, overexposureLimit);\n            float green = extendedReinhardToneMap(color.g, overexposureLimit);\n            float blue = extendedReinhardToneMap(color.b, overexposureLimit);\n            return gammaCorrectedColor(vec3(red, green, blue));\n        }\n        \n        vec3 hableFilmicHelper(vec3 color) {\n            float a = 0.15;\n            float b = 0.5;\n            float c = 0.1;\n            float d = 0.2;\n            float e = 0.02;\n            float f = 0.3;\n            return (color * (a * color + c * b) + d * e) / (color * (a * color + b) + d * f) - e / f;\n        }\n        \n        vec3 hableFilmicToneMap(vec3 color) {\n            float exposureBias = 2.0;\n            vec3 unscaled = hableFilmicHelper(exposureBias * color);\n            vec3 scale = 1.0 / hableFilmicHelper(vec3(11.2));\n            return gammaCorrectedColor(scale * unscaled);\n        }\n        \n        vec3 toneMap(vec3 color, float toneMapType, float toneMapParam) {\n            if (toneMapType == 0.0) {\n                return gammaCorrectedColor(color);\n            } else if (toneMapType == 1.0) {\n                return reinhardLuminanceToneMap(color);\n            } else if (toneMapType == 2.0) {\n                return reinhardPerChannelToneMap(color);\n            } else if (toneMapType == 3.0) {\n                return extendedReinhardLuminanceToneMap(color, toneMapParam);\n            } else if (toneMapType == 4.0) {\n                return extendedReinhardPerChannelToneMap(color, toneMapParam);\n            } else if (toneMapType == 5.0) {\n                return hableFilmicToneMap(color);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 toSrgb(vec3 linearColor, mat4 sceneProperties) {\n            vec3 referenceWhite = sceneProperties[2].rgb;\n            float unitR = linearColor.r / referenceWhite.r;\n            float unitG = linearColor.g / referenceWhite.g;\n            float unitB = linearColor.b / referenceWhite.b;\n            float toneMapType = sceneProperties[3][2];\n            float toneMapParam = sceneProperties[3][3];\n            vec3 toneMapped = toneMap(vec3(unitR, unitG, unitB), toneMapType, toneMapParam);\n            return vec4(toneMapped, 1.0);\n        }\n        \n        void main () {\n            vec3 emissiveColor = fromSrgb(texture2D(colorTexture, interpolatedUv).rgb) * backlight;\n            gl_FragColor = toSrgb(emissiveColor, sceneProperties);\n        }\n    ",attributes:{},uniforms:{backlight:"b6",colorTexture:"bH",sceneProperties:"e"}},zi=a(function(e,n,r,t,o){return l(Fa,r,c(function(r,a,i,c,l,f,d,m){return s(Va,u(Wa,c,o,m),Oa,_i,t,{b6:ei(n),bH:e,b:i,c:a,d:f,e:r,f:l})}))}),$i={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute highp vec3 normal;\n        attribute mediump vec2 uv;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        \n        varying highp vec3 interpolatedPosition;\n        varying highp vec3 interpolatedNormal;\n        varying mediump vec2 interpolatedUv;\n        varying highp vec3 interpolatedTangent;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        void main () {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            gl_Position = projectionMatrix * (viewMatrix * worldPosition);\n            interpolatedPosition = worldPosition.xyz;\n            interpolatedNormal = getWorldNormal(normal, modelScale, modelMatrix);\n            interpolatedUv = uv;\n            interpolatedTangent = vec3(0.0, 0.0, 0.0);\n        }\n    ",attributes:{normal:"p",position:"bZ",uv:"M"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",viewMatrix:"f"}},Ai=o(function(e,n,r,t){return l(Fa,n,c(function(n,o,a,i,c,l,f,d){var m=f.a,v=f.b;return s(Va,u(Wa,i,t,d),$i,li,r,{T:v,bd:m.bd,bP:m.bP,bQ:m.bQ,bR:m.bR,cp:e,b:a,c:o,aV:e,d:l,e:n,a_:0,f:c})}))}),Ri=n(9,lo=function(e,n,r,t,o,a,i,f,d){return l(Fa,i,c(function(i,c,l,m,v,p,g,b){var h=g.a,C=g.b;return s(Va,u(Wa,m,d,b),$i,si,f,{b8:e,ca:n,cb:a,cc:t,T:C,bd:h.bd,bP:h.bP,bQ:h.bQ,bR:h.bR,cs:o,b:l,c:c,aV:e,d:p,cM:r,e:i,a_:0,f:v})}))},function(e){return function(n){return function(r){return function(t){return function(o){return function(a){return function(i){return function(c){return function(l){return lo(e,n,r,t,o,a,i,c,l)}}}}}}}}}),Fi=t(function(e,n,r){return r>.5?n+(1-r)*(e-n):e+r*(n-e)}),Bi=function(e){return e.dC},ki=function(e){return e.dF},Ei=r(function(e,n){return n-e}),Vi=function(e){return P(l(Ei,e.dD,e.dA),l(Ei,e.dE,e.dB),l(Ei,ki(e),Bi(e)))},ji=function(e){var n=Vi(e),r=n.a,t=n.b,o=n.c;return{ei:ko(function(e){return u(Qo,u(Fi,(n=e).dD,n.dA,.5),u(Fi,e.dE,e.dB,.5),u(Fi,e.dF,e.dC,.5));var n}(e)),eB:r/2,eC:t/2,eD:o/2}},Hi=r(function(e,n){switch(e.$){case 0:if(e.b.$){var r=e.b.a.D;switch(n.$){case 0:case 1:case 2:case 3:case 4:return za;case 5:case 6:case 7:return R=n.c,F=n.d,f(Ua,r,ji(A=n.a),R,F);case 8:case 9:default:return za}}else{var t=e.b.a;switch(n.$){case 0:return za;case 1:case 2:case 3:case 4:case 5:case 6:case 7:return R=n.c,F=n.d,f(Ga,t,ji(A=n.a),R,F);case 8:case 9:return R=n.c,f(Ga,t,ji(A=n.a),R,0);default:return R=n.d,f(Ja,t,n.b,ji(A=n.a),R)}}case 1:if(e.b.$)switch(r=e.b.a.D,a=e.c,n.$){case 0:case 1:case 2:case 3:case 4:return za;case 5:case 6:case 7:return R=n.c,F=n.d,s(zi,r,a,ji(A=n.a),R,F);case 8:case 9:default:return za}else{var o=e.b.a,a=e.c;switch(n.$){case 0:return za;case 1:case 2:case 3:case 4:case 5:case 6:case 7:return R=n.c,F=n.d,s(ri,o,a,ji(A=n.a),R,F);case 8:case 9:return R=n.c,s(ri,o,a,ji(A=n.a),R,0);default:return R=n.d,s(oi,o,a,n.b,ji(A=n.a),R)}}case 2:var i=l(Mi,e.b,e.c);if(i.$){var m=i.a.a,v=i.b,p=v.a,g=v.b;switch(n.$){case 0:case 1:case 2:case 3:case 4:case 5:return za;case 6:return R=n.c,h=n.d,f(Ai,m,ji(A=n.a),R,h);case 7:return R=n.c,h=n.d,d(fi,m,p,g,ji(A=n.a),R,h);case 8:case 9:default:return za}}else{var b=i.a;switch(n.$){case 0:case 1:return za;case 2:R=n.c;var h=n.d;return f(ci,b,ji(A=n.a),R,h);case 3:return za;case 4:R=n.c;h=n.d;return f(ci,b,ji(A=n.a),R,h);case 5:return za;case 6:case 7:return R=n.c,h=n.d,f(ci,b,ji(A=n.a),R,h);case 8:case 9:default:return za}}default:var C=f(Si,e.b,e.c,e.d,e.e);if(C.$){var x=C.a,T=x.a,M=x.b,P=C.b,y=P.a,L=P.b,w=C.c,D=w.a,N=w.b,S=C.d;switch(p=S.a,g=S.b,n.$){case 0:case 1:case 2:case 3:case 4:case 5:return za;case 6:return R=n.c,F=n.d,B=Ri,k=T,E=M,V=y,j=L,H=D,I=N,W=ji(A=n.a),O=R,U=F,9===B.a?B.f(k,E,V,j,H,I,W,O,U):B(k)(E)(V)(j)(H)(I)(W)(O)(U);case 7:return A=n.a,R=n.c,F=n.d,function(e){return function(n){return function(r){return function(t){return function(o){return function(a){return function(i){return function(f){return function(d){return function(m){return function(v){return l(Fa,d,c(function(c,l,d,p,g,b,h,C){var x=h.a,T=h.b;return s(Va,u(Wa,p,v,C),ui,si,m,{b8:e,ca:n,cb:a,cc:t,T:T,bd:x.bd,bP:x.bP,bQ:x.bQ,bR:x.bR,cs:o,b:d,c:l,aV:i,d:b,cM:r,e:c,a_:f,f:g})}))}}}}}}}}}}}(T)(M)(y)(L)(D)(N)(p)(g)(ji(A))(R)(F);case 8:case 9:default:return za}}else{var _=C.a,z=C.b,$=C.c;switch(n.$){case 0:case 1:return za;case 2:return R=n.c,F=n.d,d(mi,_,z,$,ji(A=n.a),R,F);case 3:return za;case 4:return R=n.c,F=n.d,d(mi,_,z,$,ji(A=n.a),R,F);case 5:return za;case 6:case 7:var A,R=n.c,F=n.d;return d(mi,_,z,$,ji(A=n.a),R,F);case 8:case 9:default:return za}}}var B,k,E,V,j,H,I,W,O,U}),Ii=function(e){return e.d6},Wi=function(e){return e.d7},Oi=function(e){return e.b5},Ui=function(e){return e.cw},Yi=function(e){return e},qi=function(e){return e.cV},Gi=function(e){return e.cW},Zi=function(e){return e.cX},Xi=r(function(e,n){return{$:5,a:e,b:n}}),Ki=r(function(e,n){return{da:h(e.da,n.da),r:e.r*n.r+e.s*n.u+e.t*n.x,s:e.r*n.s+e.s*n.v+e.t*n.y,t:e.r*n.t+e.s*n.w+e.t*n.z,u:e.u*n.r+e.v*n.u+e.w*n.x,v:e.u*n.s+e.v*n.v+e.w*n.y,w:e.u*n.t+e.v*n.w+e.w*n.z,x:e.x*n.r+e.y*n.u+e.z*n.x,y:e.x*n.s+e.y*n.v+e.z*n.y,z:e.x*n.t+e.y*n.w+e.z*n.z,I:n.I+(e.I*n.r+e.J*n.u+e.K*n.x)*n.b2,J:n.J+(e.I*n.s+e.J*n.v+e.K*n.y)*n.b2,K:n.K+(e.I*n.t+e.J*n.w+e.K*n.z)*n.b2,b2:e.b2*n.b2}}),Ji=r(function(e,n){var r=n;switch(r.$){case 0:return za;case 5:var t=r.b;return l(Xi,l(Ki,r.a,e),t);case 1:case 3:case 2:default:return l(Xi,e,r)}}),Qi=r(function(e,n){return l(Ji,function(e){var n=ko(Ui(e)),r=Yi(Zi(e)),t=Yi(Gi(e)),o=Yi(qi(e));return{da:function(e){var n=e,r=Oi(n.cX),t=Wi(n.cX),o=Ii(n.cX),a=Oi(n.cW),i=Wi(n.cW),c=Ii(n.cW),l=Oi(n.cV),u=Wi(n.cV),f=Ii(n.cV);return f*i*r+u*a*o+l*c*t-l*i*o-u*c*r-f*a*t>0}(e),r:o.d6,s:o.d7,t:o.b5,u:t.d6,v:t.d7,w:t.b5,x:r.d6,y:r.d7,z:r.b5,I:n.d6,J:n.d7,K:n.b5,b2:1}}(e),n)}),ec=function(e){return{$:2,a:e}},nc=r(function(e,n){var r=e.a,t=e.b,o=e.c,a=n.ei;return{ei:{d6:r*a.d6,d7:t*a.d7,b5:o*a.b5},eB:r*n.eB,eC:t*n.eC,eD:o*n.eD}}),rc=function(e){return function(n){return function(r){return function(t){return function(o){return function(a){return function(i){return function(c){return function(l){return function(u){var f,s,d={d6:(s=t)[0],d7:s[1],b5:s[2],d5:s[3]},v=(f={d5:d.d5,d6:d.d6*e.a,d7:d.d7*e.b,b5:d.b5*e.c},new Float64Array([f.d6,f.d7,f.b5,f.d5]));return m(n,r,v,o,a,i,c,l,u)}}}}}}}}}},tc=r(function(e,n){switch(n.$){case 0:return _a;case 5:return l(Xi,n.a,l(tc,e,n.b));case 1:var r=n.b;return l(Fa,l(nc,e,n.a),l(rc,e,r));case 3:return n;case 2:return ec(l(rc,e,r=n.a));default:var t=n.a;return $a(l(Zr,tc(e),t))}}),oc=r(function(e,n){return l(tc,e,n)}),ac={src:"\n        precision lowp float;\n        \n        void main () {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    ",attributes:{},uniforms:{}},ic=function(e){return function(n){return function(r){return function(t){return function(o){return function(a){return function(i){return function(c){return function(l){return function(u){return function(f){return{$:2,a:e,b:n,c:r,d:t,e:o,f:a,g:i,h:c,i:l,j:u,k:f}}}}}}}}}}}},cc=t(function(e,n,r){return n(e(r))}),lc=t(function(e,n,t){var o=e.cJ,a=e.cn,i=e.cU,c=r(function(e,n){return n(e)}),f=r(function(e,n){return n(e)}),s=function(e){return l(cc,c(e.bp),l(cc,f(e.a8),l(cc,f(e.by),f(e.bz))))};return l(s,t,l(s,n,u(ic,o,a,i)))}),uc=u(lc,{cn:0,cJ:0,cU:15},{a8:7680,bp:519,by:7680,bz:7683},{a8:7680,bp:519,by:7680,bz:7682}),fc=u(lc,{cn:0,cJ:0,cU:15},{a8:7680,bp:519,by:7680,bz:7682},{a8:7680,bp:519,by:7680,bz:7683}),sc=r(function(e,n){return l(Xn,e?fc:uc,n)}),dc={src:"\n        precision highp float;\n        \n        attribute highp vec3 position;\n        attribute highp vec3 normal;\n        \n        uniform highp vec4 modelScale;\n        uniform highp mat4 modelMatrix;\n        uniform highp mat4 viewMatrix;\n        uniform highp mat4 projectionMatrix;\n        uniform highp mat4 sceneProperties;\n        uniform highp mat4 shadowLight;\n        \n        const lowp float kDirectionalLight = 1.0;\n        const lowp float kPointLight = 2.0;\n        \n        vec4 getWorldPosition(vec3 modelPosition, vec4 modelScale, mat4 modelMatrix) {\n            vec4 scaledPosition = vec4(modelScale.xyz * modelPosition, 1.0);\n            return modelMatrix * scaledPosition;\n        }\n        \n        vec3 safeNormalize(vec3 vector) {\n            if (vector == vec3(0.0, 0.0, 0.0)) {\n                return vector;\n            } else {\n                return normalize(vector);\n            }\n        }\n        \n        vec3 getWorldNormal(vec3 modelNormal, vec4 modelScale, mat4 modelMatrix) {\n            vec3 normalScale = vec3(modelScale.w / modelScale.x, modelScale.w / modelScale.y, modelScale.w / modelScale.z);\n            return (modelMatrix * vec4(safeNormalize(normalScale * modelNormal), 0.0)).xyz;\n        }\n        \n        vec3 getDirectionToLight(vec3 surfacePosition, vec4 xyz_type, vec4 rgb_parameter) {\n            float lightType = xyz_type.w;\n            if (lightType == kDirectionalLight) {\n                return xyz_type.xyz;\n            } else if (lightType == kPointLight) {\n                vec3 lightPosition = xyz_type.xyz;\n                return normalize(lightPosition - surfacePosition);\n            } else {\n                return vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n        vec4 shadowVertexPosition(vec3 position, vec3 normal, mat4 shadowLight, vec4 modelScale, mat4 modelMatrix, mat4 viewMatrix, mat4 projectionMatrix, mat4 sceneProperties) {\n            vec4 worldPosition = getWorldPosition(position, modelScale, modelMatrix);\n            vec3 worldNormal = getWorldNormal(normal, vec4(modelScale.xyz, 1.0), modelMatrix);\n            vec4 xyz_type = shadowLight[0];\n            vec4 rgb_parameter = shadowLight[1];\n            vec3 directionToLight = getDirectionToLight(worldPosition.xyz, xyz_type, rgb_parameter);\n            vec3 offset = vec3(0.0, 0.0, 0.0);\n            float sceneDiameter = sceneProperties[3][1];\n            if (dot(directionToLight, worldNormal) <= 0.0) {\n                offset = -sceneDiameter * directionToLight;\n            } else {\n                offset = -0.001 * sceneDiameter * directionToLight;\n            }\n            vec4 offsetPosition = worldPosition + vec4(offset, 0.0);\n            return projectionMatrix * (viewMatrix * offsetPosition);\n        }\n        \n        void main () {\n            gl_Position = shadowVertexPosition(\n                position,\n                normal,\n                shadowLight,\n                modelScale,\n                modelMatrix,\n                viewMatrix,\n                projectionMatrix,\n                sceneProperties\n            );\n        }\n    ",attributes:{normal:"p",position:"bZ"},uniforms:{modelMatrix:"b",modelScale:"c",projectionMatrix:"d",sceneProperties:"e",shadowLight:"b3",viewMatrix:"f"}},mc=function(e){var n=function(e){if(e.$){var n=e.c;return sr(c(function(e,r,t,o,a,i,c,u){return s(Va,l(sc,o,u),dc,ac,n,{b:t,c:r,d:i,e:e,b3:c,f:a})}))}return dr}(e);return n.$?za:ec(n.a)},vc=o(function(e,n,r,t){var o,a=l(Hi,r,ea),i=(o=M(e,n)).a?o.b?Ra(S([a,mc(Sa)])):a:o.b?mc(Sa):za,c=t.en,u=c.a,f=c.b,s=c.c;return l(Qi,function(e){return e}(t.ec),l(oc,P(u,f,s),i))}),pc=r(function(e,n){return f(vc,!0,!1,e,n)}),gc=function(e){return e/180*3.141592653589793},bc=r(function(e,n){return{$:0,a:e,b:n}}),hc=function(e){var n=e.b;return l(bc,1664525*e.a+n>>>0,n)},Cc=function(e){var n=e.a,r=277803737*(n^n>>>4+(n>>>28));return(r>>>22^r)>>>0},xc=r(function(e,n){return function(r){var t=hc(r),o=Wo(n-e),a=Cc(t);return M((1*(67108863&Cc(r))*134217728+1*(134217727&a))/9007199254740992*o+e,hc(t))}}),Tc=function(e){return{$:0,a:e}},Mc=a(function(e,n,r,t,o){return{$:3,a:e,b:n,c:r,d:t,e:o}}),Pc=t(function(e,n,r){return x(r,e)<0?e:x(r,n)>0?n:r}),yc=$,Lc=function(e){return u(Pc,0,1,e>.04045?l(yc,(e+.055)/1.055,2.4):e/12.92)},wc=o(function(e,n,r,t){return{$:0,a:e,b:n,c:r,d:t}}),Dc=function(e){return e/255},Nc=t(function(e,n,r){return f(wc,Dc(e),Dc(n),Dc(r),1)}),Sc=A,_c=R,zc=r(function(e,n){var r=n,t=ko(e.cw),o=.5*r,a=Sc(o),i=_c(o),c=Yi(e.eo),l=c.d6*i,u=a*l,f=l*l,s=c.d7*i,d=a*s,m=l*s,v=s*s,p=1-2*(f+v),g=c.b5*i,b=a*g,h=2*(m-b),C=2*(m+b),x=l*g,T=2*(x+d),M=2*(x-d),P=s*g,y=2*(P-u),L=2*(P+u),w=g*g,D=1-2*(v+w),N=1-2*(f+w);return{da:!0,r:D,s:C,t:M,u:h,v:N,w:L,x:T,y:y,z:p,I:t.d6-D*t.d6-h*t.d7-T*t.b5,J:t.d7-C*t.d6-N*t.d7-y*t.b5,K:t.b5-M*t.d6-L*t.d7-p*t.b5,b2:1}}),$c=t(function(e,n,r){return l(Ji,l(zc,e,n),r)}),Ac=t(function(e,n,r){return u($c,e,n,r)}),Rc=r(function(e,n){return e(n)}),Fc=r(function(e,n){return{eo:n,cw:e}}),Bc=function(e){return M(1,e)},kc=t(function(e,n,r){for(;;){var t=e.a,o=e.b;if(!n.b)return o;var a=n.a,i=n.b;if(x(r,Wo(t))<1)return o;e=a,n=i,r-=Wo(t)}}),Ec=r(function(e,n){var r=n;return function(n){var t=r(n),o=t.b;return M(e(t.a),o)}}),Vc=r(function(e,n){var r=function(e){return Wo(e.a)},t=r(e)+u(pr,fr,0,l(Zr,r,n));return l(Ec,l(kc,e,n),l(xc,0,t))}),jc=r(function(e,n){return l(Vc,Bc(e),l(Zr,Bc,n))}),Hc=function(e){return Wo(e)},Ic=r(function(e,n){return x(n,e)>-1}),Wc=r(function(e,n){return e+.5*(n-e)}),Oc=function(e){return e},Uc=Oc({d6:-1,d7:0,b5:0}),Yc=Oc({d6:0,d7:-1,b5:0}),qc=Oc({d6:0,d7:0,b5:-1}),Gc=Oc({d6:1,d7:0,b5:0}),Zc=Oc({d6:0,d7:1,b5:0}),Xc=Oc({d6:0,d7:0,b5:1}),Kc=function(e){return e},Jc=i(function(e,n,r,t,o,a){var i=l(Ic,r,a)?Xc:qc,c=l(Ic,n,o)?Zc:Yc,f=l(Ic,e,t)?Gc:Uc,s=P(Hc(l(Ei,e,t)),Hc(l(Ei,n,o)),Hc(l(Ei,r,a)));return{ec:Kc({cw:u(Qo,l(Wc,e,t),l(Wc,n,o),l(Wc,r,a)),cV:f,cW:c,cX:i}),en:s}}),Qc=o(function(e,n,r,t){var o=function(e){return gc(e+n/500)},a=l(Rc,l(po,function(e){return l(jc,(n=o(e),{d6:Sc(r=n),d7:_c(r),b5:0}),S([function(){var n=o(e);return{d6:0,d7:Sc(n),b5:_c(n)}}(),function(){var n=o(e);return{d6:0,d7:_c(n),b5:Sc(n)}}()]));var n,r},l(xc,0,1e4)),function(e){var n=hc(l(bc,0,1013904223));return hc(l(bc,n.a+e>>>0,n.b))}(r+1e3*t)).a;return u(Ac,l(Fc,u(Qo,Ko(r+.3+e),Ko(t+.3+e),Ko(.3)),a),gc(n/150+r/3+t/3),l(pc,function(e){return function(e){var n=e.eX,r=e.cr;return s(Mc,0,Tc(function(e){var n={aL:e.d,b9:e.c,cd:e.b,cI:e.a},r=n.cd,t=n.b9;return u(Ta,Lc(n.cI),Lc(r),Lc(t))}(e.ee)),Tc(u(Pc,0,1,n)),Tc(u(Pc,0,1,r)),Tc(0))}({ee:e.ee,cr:0,eX:e.eX})}({ee:u(Nc,91,192,235),eX:.6}),function(e){return d(Jc,e.fc,e.ff,e.fi,e.fd,e.fg,e.fj)}({fc:Ko(e+r),fd:Ko(e+r+.6),ff:Ko(e+t),fg:Ko(e+t+.6),fi:Ko(0),fj:Ko(.6)})))}),el=r(function(e,n){return Na(l(Zr,e,n))}),nl=Re("div"),rl=function(e){return e},tl=function(e){var n=e,r=l($r,Wo(n.d6),l($r,Wo(n.d7),Wo(n.b5)));if(r){var t=n.b5/r,o=n.d7/r,a=n.d6/r,i=Oo(a*a+o*o+t*t);return sr({d6:a/i,d7:o/i,b5:t/i})}return dr},ol=r(function(e,n){return n.$?dr:e(n.a)}),al=r(function(e,n){return n.d6*e.d6+n.d7*e.d7+n.b5*e.b5}),il=r(function(e,n){return x(n,e)>0}),cl=r(function(e,n){return x(n,e)<0}),ll=r(function(e,n){return n.$?dr:sr(e(n.a))}),ul=r(function(e,n){return{d6:n.d6-e.d6,d7:n.d7-e.d7,b5:n.b5-e.b5}}),fl=r(function(e,n){var r=n.d6*e.d6+n.d7*e.d7+n.b5*e.b5;return{d6:e.d6*r,d7:e.d7*r,b5:e.b5*r}}),sl=t(function(e,n,r){return l(ol,function(t){return l(ol,function(o){var a,i=l(jo,n,e),c=l(al,r,i),u=l(il,0,c)?i:l(cl,0,c)?{d6:-(a=i).d6,d7:-a.d7,b5:-a.b5}:Uo;return l(ll,function(e){return P(t,o,e)},tl(u))},tl(l(ul,l(fl,t,n),n)))},tl(e))}),dl=function(e){var n=function(){var n=e,r=Wo(n.b5),t=Wo(n.d7),o=Wo(n.d6);if(x(o,t)<1){if(x(o,r)<1){var a=Oo(n.b5*n.b5+n.d7*n.d7);return{d6:0,d7:-n.b5/a,b5:n.d7/a}}return a=Oo(n.d7*n.d7+n.d6*n.d6),{d6:-n.d7/a,d7:n.d6/a,b5:0}}return x(t,r)<1?(a=Oo(n.b5*n.b5+n.d6*n.d6),{d6:n.b5/a,d7:0,b5:-n.d6/a}):(a=Oo(n.d6*n.d6+n.d7*n.d7),{d6:-n.d7/a,d7:n.d6/a,b5:0})}();return M(n,{d6:e.d7*n.b5-e.b5*n.d7,d7:e.b5*n.d6-e.d6*n.b5,b5:e.d6*n.d7-e.d7*n.d6})},ml=r(function(e,n){var r=dl(e);return Kc({cw:n,cV:r.a,cW:r.b,cX:e})}),vl=t(function(e,n,r){return{d6:e,d7:n,b5:r}}),pl=function(e){return.5*e},gl=F,bl=Be,hl={$:3},Cl=o(function(e,n,r,t){return{$:4,a:e,b:n,c:r,d:t}}),xl=function(e){return Fe(function(e){return"script"==e?"p":e}(e))},Tl=I,Ml=t(function(e,n,r){return u(Hn,e,n,r)}),Pl=function(e){return e},yl=f(Ci,1,1,1,1),Ll=t(function(e,n,r){return l(Zr,function(e){return l(e,n,r)},e)}),wl=t(function(e,n,r){return{$:0,a:e,b:n,c:r}}),Dl=r(function(e,n){var r=n.d6,t=n.d7;return u(wl,e*r/t,e,e*(1-r-t)/t)}),Nl=r(function(e,n){return u(Ta,3.2406*(t=(r=l(Dl,e,n)).a)-1.5372*(o=r.b)-.4986*(a=r.c),-.9689*t+1.8758*o+.0415*a,.0557*t-.204*o+1.057*a);var r,t,o,a}),Sl=function(e){var n=new Float64Array(16);return n[0]=e.dj,n[1]=e.dn,n[2]=e.dr,n[3]=e.dv,n[4]=e.dk,n[5]=e.$7,n[6]=e.ds,n[7]=e.dw,n[8]=e.dl,n[9]=e.dp,n[10]=e.dt,n[11]=e.dx,n[12]=e.dm,n[13]=e.dq,n[14]=e.du,n[15]=e.dy,n},_l=a(function(e,n,r,t,o){return d(o,e,f(Ci,t.b2,t.b2,t.b2,t.da?1:-1),function(e){return Sl({dj:e.r,dk:e.u,dl:e.x,dm:e.I,dn:e.s,$7:e.v,dp:e.y,dq:e.J,dr:e.t,ds:e.w,dt:e.z,du:e.K,dv:0,dw:0,dx:0,dy:1})}(t),t.da,n,r)}),zl=i(function(e,n,r,t,o,a){e:for(;;)switch(o.$){case 0:return a;case 5:var i=o.b;e=e,n=n,r=r,t=l(Ki,o.a,t),o=i,a=a;continue e;case 1:return{O:l(Xn,s(_l,e,n,r,t,o.b),a.O),Z:a.Z,eY:a.eY};case 3:return{O:a.O,Z:l(Xn,s(_l,e,n,r,t,o.b),a.Z),eY:a.eY};case 2:return{O:a.O,Z:a.Z,eY:l(Xn,s(_l,e,n,r,t,o.a),a.eY)};default:var c=o.a;return u(pr,f(zl,e,n,r,t),a,c)}}),$l=o(function(e,n,r,t){return{$:4,a:e,b:n,c:r,d:t}}),Al=o(function(e,n,r,t){return{$:1,a:e,b:n,c:r,d:t}}),Rl=r(function(e,n){return{$:6,a:e,b:n}}),Fl=S([({_:1,aa:0,ad:!1},f(Al,518,!1,0,1)),f($l,!1,!1,!1,!1),l(Rl,0,1)]),Bl={src:"\n        precision lowp float;\n\n        void main() {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n    ",attributes:{},uniforms:{}},kl=r(function(e,n){return{$:0,a:e,b:n}})({c1:1,c9:0,dH:5})(S([{bZ:l(wi,-1,-1)},{bZ:l(wi,1,-1)},{bZ:l(wi,-1,1)},{bZ:l(wi,1,1)}])),El={src:"\n        precision lowp float;\n\n        attribute vec2 position;\n\n        void main() {\n            gl_Position = vec4(position, 0.0, 1.0);\n        }\n    ",attributes:{position:"bZ"},uniforms:{}},Vl=function(e){return u(lc,{cn:e.cn,cJ:e.cJ,cU:e.cU},{a8:e.a8,bp:e.bp,by:e.by,bz:e.bz},{a8:e.a8,bp:e.bp,by:e.by,bz:e.bz})},jl=function(e){return s(Va,S([Vl(e),f($l,!1,!1,!1,!1)]),El,Bl,kl,{})},Hl=jl({a8:7681,cn:0,cJ:8,bp:519,cU:15,by:7681,bz:7681}),Il=function(e){return jl({a8:7680,cn:15,cJ:8,bp:516,cU:(n=e,l(yc,2,n+4)),by:5386,bz:5386});var n},Wl=t(function(e,n,r){return Na(S([u(Ll,e,r,Fl),S([Il(n),Hl])]))}),Ol=r(function(e,n){return Na(l(xr,Wl(e),n))}),Ul=f(Al,513,!0,0,1),Yl=t(function(e,n,r){return{$:0,a:e,b:n,c:r}}),ql=r(function(e,n){return u(Yl,32774,e,n)}),Gl=function(e){var n=e.b$,t=e.bK,o=e.bD,a=e.bA,i=e.bG,c=e.aL;return l(r(function(e,r){var i=e.b,c=e.c,l=r.a,u=r.b,f=r.c;return function(e){return function(n){return function(r){return function(t){return function(o){return function(a){return function(i){return function(c){return function(l){return function(u){return{$:0,a:e,b:n,c:r,d:t,e:o,f:a,g:i,h:c,i:l,j:u}}}}}}}}}}}(e.a)(i)(c)(l)(u)(f)(n)(t)(o)(a)}),i,c)}({bA:0,aL:l(ql,1,771),bD:0,bG:l(ql,770,771),bK:0,b$:0}),Zl=S([Ul,Gl]),Xl=function(e){return Ui(e)},Kl=function(e){return Kc({cw:(n={d6:e.I,d7:e.J,b5:e.K},n),cV:Oc({d6:e.r,d7:e.s,b5:e.t}),cW:Oc({d6:e.u,d7:e.v,b5:e.w}),cX:Oc({d6:e.x,d7:e.y,b5:e.z})});var n},Jl=r(function(e,n){var r=e.cX,t=e.cW,o=e.cV;return{d6:n.d6*o.d6+n.d7*o.d7+n.b5*o.b5,d7:n.d6*t.d6+n.d7*t.d7+n.b5*t.b5,b5:n.d6*r.d6+n.d7*r.d7+n.b5*r.b5}}),Ql=r(function(e,n){var r=e.cw,t=n.d6-r.d6,o=n.d7-r.d7,a=n.b5-r.b5,i=e.cX,c=e.cW,l=e.cV;return{d6:t*l.d6+o*l.d7+a*l.b5,d7:t*c.d6+o*c.d7+a*c.b5,b5:t*i.d6+o*i.d7+a*i.b5}}),eu=r(function(e,n){return{cw:l(Ql,e,Ui(n)),cV:l(Jl,e,qi(n)),cW:l(Jl,e,Gi(n)),cX:l(Jl,e,Zi(n))}}),nu=r(function(e,n){var r=yo(n),t=yo(e);return{dA:l(Lo,t.dA,r.dA),dB:l(Lo,t.dB,r.dB),dC:l(Lo,t.dC,r.dC),dD:l(Do,t.dD,r.dD),dE:l(Do,t.dE,r.dE),dF:l(Do,t.dF,r.dF)}}),ru=r(function(e,n){return n+e}),tu=r(function(e,n){var r=e.a,t=e.c,o=pl(Hc(e.b)),a=pl(Hc(r)),i=pl(Hc(t)),c=P(n.d6,n.d7,n.b5),u=c.a,f=c.b,s=c.c;return{dA:l(ru,a,u),dB:l(ru,o,f),dC:l(ru,i,s),dD:l(Ei,a,u),dE:l(Ei,o,f),dF:l(Ei,i,s)}}),ou=o(function(e,n,r,t){var o=r.ei,a=2*r.eD*n,i=2*r.eC*n,c=2*r.eB*n,f=o.b5*n,s=o.d7*n,d=o.d6*n,m=Yi(Zi(e)),v=Wo(c*m.d6)+Wo(i*m.d7)+Wo(a*m.b5),p=Yi(Gi(e)),g=Wo(c*p.d6)+Wo(i*p.d7)+Wo(a*p.b5),b=Yi(qi(e)),h=Wo(c*b.d6)+Wo(i*b.d7)+Wo(a*b.b5),C=l(tu,P(h,g,v),l(Ql,e,u(vl,d,s,f)));return sr(t.$?C:l(nu,t.a,C))}),au=o(function(e,n,r,t){e:for(;;){if(!t.b)return r;var o=t.a,a=t.b;switch(o.$){case 0:e=c=e,n=u=n,r=s=r,t=a;continue e;case 1:var i=f(ou,e,n,o.a,r);e=c=e,n=u=n,r=s=i,t=a;continue e;case 2:e=c=e,n=u=n,r=s=r,t=a;continue e;case 3:i=f(ou,e,n,o.a,r),e=c=e,n=u=n,r=s=i,t=a;continue e;case 4:var c=e,u=n,s=f(au,e,n,r,o.a);e=c,n=u,r=s,t=a;continue e;default:var d=o.a,m=o.b,v=l(eu,Kl(d),e),p=n*d.b2;e=c=e,n=u=n,r=s=f(au,v,p,r,S([m])),t=a;continue e}}}),iu={da:!0,r:1,s:0,t:0,u:0,v:1,w:0,x:0,y:0,z:1,I:0,J:0,K:0,b2:1},cu=jl({a8:7681,cn:0,cJ:8,bp:519,cU:255,by:7681,bz:7681}),lu={bD:0,eh:!1,bK:0,cF:0,b$:0,cR:0,d6:0,d7:0,b5:0},uu=r(function(e,n){return Sl({dj:e.d6,dk:e.b$,dl:n.d6,dm:n.b$,dn:e.d7,$7:e.bK,dp:n.d7,dq:n.bK,dr:e.b5,ds:e.bD,dt:n.b5,du:n.bD,dv:e.cR,dw:e.cF,dx:n.cR,dy:n.cF})}),fu=M({bd:l(uu,lu,lu),bP:l(uu,lu,lu),bQ:l(uu,lu,lu),bR:l(uu,lu,lu)},f(Ci,0,0,0,0)),su=function(e){return-e},du=function(e){return f(Al,515,e.ad,e.aa,e._)},mu=S([du({_:1,aa:0,ad:!0}),Vl({a8:7680,cn:240,cJ:0,bp:514,cU:0,by:7680,bz:7680}),Gl]),vu=function(e){return e===1/0||e===-1/0},pu=r(function(e,n){var r=e,t=n.ez,o=n.eb,a=Hc(n.eP),i=Hc(t),c=r.cH;if(c.$){var l=c.a;return vu(i)?Sl({dj:2/(o*l),dk:0,dl:0,dm:0,dn:0,$7:2/l,dp:0,dq:0,dr:0,ds:0,dt:0,du:-1,dv:0,dw:0,dx:0,dy:1}):Sl({dj:2/(o*l),dk:0,dl:0,dm:0,dn:0,$7:2/l,dp:0,dq:0,dr:0,ds:0,dt:-2/(i-a),du:-(i+a)/(i-a),dv:0,dw:0,dx:0,dy:1})}var u=c.a;return vu(i)?Sl({dj:1/(o*u),dk:0,dl:0,dm:0,dn:0,$7:1/u,dp:0,dq:0,dr:0,ds:0,dt:-1,du:-2*a,dv:0,dw:0,dx:-1,dy:0}):Sl({dj:1/(o*u),dk:0,dl:0,dm:0,dn:0,$7:1/u,dp:0,dq:0,dr:0,ds:0,dt:-(i+a)/(i-a),du:-2*i*a/(i-a),dv:0,dw:0,dx:-1,dy:0})}),gu=r(function(e,n){return 1===(1&e>>n)?0:1}),bu=t(function(e,n,r){return Na(l(Zr,function(r){var t=r<<4;return u(Ll,e,M(n,f(Ci,l(gu,r,0),l(gu,r,1),l(gu,r,2),l(gu,r,3))),function(e){return S([du({_:1,aa:0,ad:!0}),Vl({a8:7680,cn:240,cJ:e,bp:514,cU:0,by:7680,bz:7680}),Gl])}(t))},l(Cr,1,l(yc,2,r)-1)))}),hu=function(e){return{d6:-e.d6,d7:-e.d7,b5:-e.b5}},Cu=function(e){return hu(Zi(e))},xu={cw:{d6:0,d7:0,b5:0},cV:Gc,cW:Zc,cX:Xc},Tu=r(function(e,n){var r,t,o,a,i;return t=ko(Ui(r=l(eu,n,e))),o=Yi(Zi(r)),a=Yi(Gi(r)),i=Yi(qi(r)),Sl({dj:i.d6,dk:a.d6,dl:o.d6,dm:t.d6,dn:i.d7,$7:a.d7,dp:o.d7,dq:t.d7,dr:i.b5,ds:a.b5,dt:o.b5,du:t.b5,dv:0,dw:0,dx:0,dy:1})}),Mu=t(function(e,n,r){return{d6:e,d7:n,b5:r}}),Pu=r(function(e,n){var r,t,o=S([(t=1,{$:1,a:t}),function(e){return{$:2,a:e}}(0),function(e){return{$:0,a:e}}(!0),f(Cl,0,0,0,0)]),a=function(){var n=e.aM;switch(n.$){case 0:return P(o,"0",1);case 1:return P(l(Xn,hl,o),"1",1);default:return P(o,"0",n.a)}}(),i=a.a,c=a.b,s=a.c,m=e.en,v=m.a,p=Pl(m.b),g=l(bl,"height",mr(p)+"px"),b=Pl(v),h=b/p,C=l(el,function(n){return function(e){var n=e.eg.e7,r=Kc({cw:Xl(n),cV:qi(n),cW:Gi(n),cX:hu(Cu(n))}),t=Ra(e.et),o=f(au,r,1,dr,S([t]));if(1===o.$)return w;var a,i=o.a,c=l(Tu,xu,n),s=l(Jo,.99,l(Lo,Hc(e.ek),su(Bi(i)))),m=Vi(i),v=function(){var e=u(Mu,m.a,m.b,m.c),n=l($r,Wo(e.d6),l($r,Wo(e.d7),Wo(e.b5)));if(n){var r=e.b5/n,t=e.d7/n,o=e.d6/n;return Oo(o*o+t*t+r*r)*n}return 0}(),p=l(Jo,1.01,l(ru,v,su(ki(i)))),g=l(pu,e.eg,{eb:e.eb,ez:p,eP:s}),b=(a=g,{dj:a[0],dn:a[1],dr:a[2],dv:a[3],dk:a[4],$7:a[5],ds:a[6],dw:a[7],dl:a[8],dp:a[9],dt:a[10],dx:a[11],dm:a[12],dq:a[13],du:a[14],dy:a[15]}).dy,h=b?Yi(hu(Cu(n))):ha(Xl(n)),C=function(){var n=e.aw;switch(n.$){case 0:return M(0,0);case 1:return M(1,0);case 2:return M(2,0);case 3:return M(3,n.a);case 4:return M(4,n.a);default:return M(5,0)}}(),x=C.a,T=C.b,P=l(Nl,e.ap,e.az),y=Sl({dj:0,dk:h.d6,dl:gi(P),dm:e.d$,dn:0,$7:h.d7,dp:bi(P),dq:v,dr:0,ds:h.b5,dt:hi(P),du:x,dv:0,dw:b,dx:0,dy:T}),L=d(zl,y,c,g,iu,t,{O:w,Z:w,eY:w}),D=e.ar;switch(D.$){case 0:return Na(S([u(Ll,L.O,M(N=D.a,yl),Zl),u(Ll,L.Z,fu,Zl)]));case 1:var N=D.a;return Na(S([u(Ll,L.O,fu,Zl),S([cu]),u(Ll,L.eY,N.bd,Fl),S([Il(0)]),u(Ll,L.O,M(N,yl),mu),u(Ll,L.Z,fu,Zl)]));default:var _=D.a,z=D.b;return Na(S([u(Ll,L.O,M(z,yl),Zl),S([cu]),l(Ol,L.eY,_),u(bu,L.O,z,gr(_)),u(Ll,L.Z,fu,Zl)]))}}({eb:h,eg:e.eg,ek:e.ek,et:n.et,ap:n.ap,ar:n.ar,d$:s,aw:n.aw,az:n.az})},n),x=l(bl,"width",mr(b)+"px"),T=function(e){var n,r,t=e.b,o=e.c,a=e.d,i=function(e){return at(1e4*e)/100};return n=S(["rgba(",Tl(i(e.a)),"%,",Tl(i(t)),"%,",Tl(i(o)),"%,",Tl((r=a,at(1e3*r)/1e3)),")"]),l(vr,"",n)}(e.ed);return u(xl,"div",S([l(bl,"padding","0px"),x,g]),S([M(c,u(Ml,i,S([(r=at(b*s),l(ke,"width",mr(r))),function(e){return l(ke,"height",mr(e))}(at(p*s)),x,g,l(bl,"display","block"),l(bl,"background-color",T)]),C))]))}),yu=function(e){return e},Lu=yu({d6:.31271,d7:.32902}),wu=r(function(e,n){var r=e,t=Yi(n.eo),o=t.d6,a=t.d7,i=t.b5,c=l(Nl,n.ce,n.bF);return{bD:hi(c),eh:r,bK:bi(c),cF:0,b$:gi(c),cR:1,d6:-o,d7:-a,b5:-i}}),Du=function(e){return e},Nu={$:1},Su={$:0},_u=function(e){return e},zu=function(e){return function(e){for(;;){if(h(e.eJ,0)&&h(e.eK,0))return lu;if(!l(il,Hc(e.eJ),Hc(e.eK))){var n=Wo(_u(e.eK)/3.141592653589793),r=Wo(_u(e.eJ)/3.141592653589793),t=Yi(e.d4),o=t.d6,a=t.d7,i=t.b5,c=l(Nl,Io(1),e.bF);return{bD:r*hi(c),eh:!1,bK:r*bi(c),cF:n/r,b$:r*gi(c),cR:3,d6:o,d7:a,b5:i}}e={bF:e.bF,eJ:e.eK,eK:e.eJ,d4:hu(e.d4)}}}({bF:e.bF,eJ:e.ce,eK:0,d4:e.d4})},$u=function(e){var n=u(Pc,1667,25e3,e),r=n>4e3?-3025846900/(n*n*n)+2107037.9/(n*n)+.2226347*1e3/n+.24039:1e9*-.2661239/(n*n*n)-.2343589*1e6/(n*n)+877.6956/n+.17991;return yu({d6:r,d7:n>2222?n>4e3?r*r*r*3.081758-r*r*5.8733867+3.75112997*r-.37001483:r*r*r*-.9549476-r*r*1.37418593+2.09137015*r-.16748867:r*r*r*-1.1063814-r*r*1.3481102+2.18555832*r-.20219683})},Au=function(e){return e},Ru=$u(Au(12e3)),Fu=$u(Au(5600)),Bu=r(function(e,n){return{$:2,a:e,b:n}}),ku=function(e){return{$:0,a:e}},Eu=function(e){return e},Vu=function(e){return e.eh},ju=ku(fu.a),Hu=r(function(e,n){return u(Gr,r(function(n,r){var t=r.a,o=r.b;return e(n)?M(l(Xn,n,t),o):M(t,l(Xn,n,o))}),M(w,w),n)}),Iu=function(e){return Sl({dj:e.d6,dk:e.b$,dl:0,dm:0,dn:e.d7,$7:e.bK,dp:0,dq:0,dr:e.b5,ds:e.bD,dt:0,du:0,dv:e.cR,dw:e.cF,dx:0,dy:0})},Wu=c(function(e,n,r,t,o,a,i,c){var u=l(Hu,Vu,S([Eu(e),Eu(n),Eu(r),Eu(t)])),f=u.a;if(f.b){var s=L(f,u.b);if(s.b&&s.b.b&&s.b.b.b&&s.b.b.b.b&&!s.b.b.b.b.b){var d=s.a,m=s.b,v=m.a,p=m.b,g=p.a,b=p.b.a;return l(Bu,l(Zr,Iu,f),{bd:l(uu,d,v),bP:l(uu,g,b),bQ:l(uu,o,a),bR:l(uu,i,c)})}return ju}return ku({bd:l(uu,e,n),bP:l(uu,r,t),bQ:l(uu,o,a),bR:l(uu,i,c)})}),Ou=t(function(e,n,r){return m(Wu,e,n,r,lu,lu,lu,lu,lu)}),Uu=f(o(function(e,n,r,t){return f(wc,e,n,r,t)}),0,0,0,0);io={Main:{init:ot({eI:function(){return it},e0:tr(jr(S([(ao=rr,u(so,1,"resize",l(xt,"target",u(Ir,ao,l(xt,"innerWidth",Tt),l(xt,"innerHeight",Tt))))),(co=function(e){return{$:2,a:e}},Ct(ct(co)))]))),e3:vo,e6:function(e){var n,r,t,o=(n={e5:gc(35),e7:function(e){var n=l(Ho,e.eA,e.ex),r=e.d4,t=u(sl,n,r,l(jo,n,r));if(t.$){var o=tl(n);if(o.$){var a=dl(e.d4);return Kc({cw:e.ex,cV:a.b,cW:e.d4,cX:a.a})}return l(ml,o.a,e.ex)}var i=t.a;return Kc({cw:e.ex,cV:i.c,cW:i.b,cX:i.a})}({ex:u(vl,0,0,85),eA:u(vl,0,0,0),d4:Xc})},t=pl(Hc(n.e5)),{cH:(r=gl(t),{$:0,a:r}),e7:n.e7});return l(nl,S([l(bl,"width",mr(e.bk)+"px"),l(bl,"height",mr(e.bl)+"px"),l(bl,"background-color","rgb(33, 26, 64)")]),S([function(e){var n=l(wu,e.eY,{bF:Fu,eo:e.e1,ce:Du(8e4)}),r=zu({bF:Ru,ce:Du(2e4),d4:e.d4}),t=zu({bF:Lu,ce:Du(15e3),d4:hu(e.d4)}),o=u(Ou,n,r,t);return function(e){return l(Pu,{aM:e.aM,ed:e.ed,eg:e.eg,ek:e.ek,en:e.en},S([{et:e.et,ap:e.ap,ar:e.ar,aw:e.aw,az:e.az}]))}({aM:Nu,ed:e.ed,eg:e.eg,ek:e.ek,en:e.en,et:e.et,ap:1.2*l(yc,2,15),ar:o,aw:Su,az:Lu})}({ed:Uu,eg:o,ek:Ko(.1),en:M(rl(e.bk),rl(e.bl)),et:l(el,function(n){return l(Zr,function(r){return f(Qc,-25.5,e.bs,n,r)},l(Cr,1,50))},l(Cr,1,50)),eY:!0,e1:qc,d4:Xc})]))}})((uo=0,{$:0,a:uo}))(0)}},e.Elm?function e(n,r){for(var t in r)t in n?"init"==t?b(6):e(n[t],r[t]):n[t]=r[t]}(e.Elm,io):e.Elm=io}(this)},function(e,n,r){r(3),e.exports=r(11)},,,,,,,,function(){},function(e,n,r){"use strict";r.r(n),r(10);var t=r(1);"localhost"!==window.location.hostname&&"[::1]"!==window.location.hostname&&window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/),t.Elm.Main.init({node:document.getElementById("root")}),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(function(e){e.unregister()})}],[[2,1,2]]]);
//# sourceMappingURL=main.53e205af.chunk.js.map